<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>c#学习 | ようこそ、わが楽園へ!</title><meta name="author" content="takahasi193"><meta name="copyright" content="takahasi193"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="#web_bg{   background: url(&quot;..&#x2F;simon1.jpg&quot;)!important;   &#x2F;*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*&#x2F;   background-position: center !important;   background-size: cover !important;   background-r">
<meta property="og:type" content="article">
<meta property="og:title" content="c#学习">
<meta property="og:url" content="https://takahasi193.github.io/2025/07/12/c-%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="ようこそ、わが楽園へ!">
<meta property="og:description" content="#web_bg{   background: url(&quot;..&#x2F;simon1.jpg&quot;)!important;   &#x2F;*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*&#x2F;   background-position: center !important;   background-size: cover !important;   background-r">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://takahasi193.github.io/simon1.jpg">
<meta property="article:published_time" content="2025-07-12T15:00:15.000Z">
<meta property="article:modified_time" content="2025-09-05T04:32:19.542Z">
<meta property="article:author" content="takahasi193">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://takahasi193.github.io/simon1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "c#学习",
  "url": "https://takahasi193.github.io/2025/07/12/c-%E5%AD%A6%E4%B9%A0/",
  "image": "https://takahasi193.github.io/simon1.jpg",
  "datePublished": "2025-07-12T15:00:15.000Z",
  "dateModified": "2025-09-05T04:32:19.542Z",
  "author": [
    {
      "@type": "Person",
      "name": "takahasi193",
      "url": "https://takahasi193.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://takahasi193.github.io/2025/07/12/c-%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c#学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/mycustom.css"><link rel="stylesheet" href="/css/progress_bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/299e78170924ab18fc61d81073fae6cd7a890b9f.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/my894.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Link/"><i class="fa-fw fas fa-Link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/simon1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ようこそ、わが楽園へ!</span></a><a class="nav-page-title" href="/"><span class="site-name">c#学习</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Link/"><i class="fa-fw fas fa-Link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">c#学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-12T15:00:15.000Z" title="发表于 2025-07-12 23:00:15">2025-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-05T04:32:19.542Z" title="更新于 2025-09-05 12:32:19">2025-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container">
<style>
#web_bg{
  background: url("../simon1.jpg")!important;
  /*重新定义background会导致原有定位属性失效，所以也需要再声明一次加权的定位属性*/
  background-position: center !important;
  background-size: cover !important;
  background-repeat: no-repeat !important;
}
</style>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文记录c#学习，仅供个人参考。</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="控制台方法相关"><a href="#控制台方法相关" class="headerlink" title="控制台方法相关"></a>控制台方法相关</h2><p>使用命名空间System中的console类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Project</span></span><br><span class="line">&#123;</span><br><span class="line">  internalk <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine();<span class="comment">//输出（自动换行）</span></span><br><span class="line">      Console.Write();<span class="comment">//输出（不会自动换行）</span></span><br><span class="line">      Console.ReadLine();<span class="comment">//用户端输入</span></span><br><span class="line">      Console.ReadKey();<span class="comment">//检测玩家是否输入（只能输入一个字符）</span></span><br><span class="line">      Console.Readkey(<span class="literal">true</span>).keychar<span class="comment">//得到输入的内容,返回输入的字符,若填了true则窗口不会显示输入的内容</span></span><br><span class="line">      Console.Clear();<span class="comment">//清空</span></span><br><span class="line">      <span class="comment">//设置控制台大小，缓冲区大小</span></span><br><span class="line">      Console.SetWindowSize(width,height);<span class="comment">//下同</span></span><br><span class="line">      Console.SetBufferSize();</span><br><span class="line">      <span class="comment">//控制台左上角是原点，右边是x正半轴，下边是y轴正半轴。</span></span><br><span class="line">      <span class="comment">//设置光标位置</span></span><br><span class="line">      Console.SetCursorPosition(left,top);<span class="comment">//横纵距离单位不同,1y=2x;</span></span><br><span class="line">      Console.ForegroundColor=ConsoleColor.red;<span class="comment">//改变文字颜色(例子中设置成了红色)</span></span><br><span class="line">      Console.BackgroundColor=ConsoleColor.white;<span class="comment">//改变背景颜色(例子中设置成了白色)</span></span><br><span class="line">      <span class="comment">//如果想要窗口全变色的话,设置完颜色后需要执行一次clear清空之前的文字。</span></span><br><span class="line">         Console.CursorVisible = <span class="literal">false</span>;<span class="comment">//光标显隐(有true和false两种状态,当为false时光标不显示)</span></span><br><span class="line">      Environment.Exit(<span class="number">0</span>);<span class="comment">//关闭控制台</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变量相关"><a href="#变量相关" class="headerlink" title="变量相关"></a>变量相关</h2><p>输入#region，再按tab键自动补全，可以将#region和#endregion之间的代码折叠起来</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">Project</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">        &#123;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">region</span> myregion</span></span><br><span class="line">                <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的区别：float浮点数申请需要末尾加一个f，不加的话默认是double类型，float有效数字保留8位，从第一个非零数字开始数起，decimal能存储25~27位的有效数字，但不建议使用，末尾加m；c#中char类型占两个字节，能用汉字赋初值，但部分生僻字不能。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>隐式和显式转换和c语言，c++没多大差别。字符串转换：类型.Parse(“字符串”);（比如说int.Parse(“123”)等于整型123）。</p>
<p>Convert.To类型名();转换精度更高。其他类型转string：变量类型.toString();</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说</span></span><br><span class="line"><span class="built_in">string</span> str=<span class="number">1.</span>toString();</span><br><span class="line">str=<span class="literal">true</span>.toString();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;12354&quot;</span>+<span class="number">1</span>+<span class="literal">true</span>);<span class="comment">//这里1和true会自动转换成字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse示例</span></span><br><span class="line"><span class="built_in">int</span> a=<span class="built_in">int</span>.Parse(<span class="string">&quot;123&quot;</span>);<span class="comment">//此时a里的值为123</span></span><br><span class="line"><span class="built_in">char</span> b=<span class="built_in">char</span>.Parse(<span class="string">&quot;A&quot;</span>);<span class="comment">//此时b里的值为A</span></span><br></pre></td></tr></table></figure>



<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//希望进行异常捕获的语法快放入try中</span></span><br><span class="line">    <span class="comment">//如果try中的代码报错了就不会让程序卡死</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//然后跳入catch中执行catch中的代码</span></span><br><span class="line">    <span class="comment">//catch(Exception e) 进行具体的报错追踪，通过e得到具体的报错信息</span></span><br><span class="line">&#125;<span class="comment">//到此为必备部分</span></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//最后执行的代码，不过程序有没有出错都会执行其中的代码</span></span><br><span class="line">&#125;<span class="comment">//可选部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>直接将字符串+字符串就能实现拼接。</p>
<p>或者使用string.Format(“带拼接的内容”,内容1，内容2…..);（有点类似于格式化输出）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;を愛するみんなさん、&#123;1&#125;んにちは！、ハメドリ君だ&#123;2&#125;&quot;</span>,<span class="string">&quot;ドスケベセックス&quot;</span>,<span class="string">&quot;シコ&quot;</span>,<span class="string">&quot;ハメ&quot;</span>);</span><br><span class="line"><span class="comment">//要用0~n加大括号表示要拼接的内容，后面写要拼接的内容。</span></span><br></pre></td></tr></table></figure>



<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位与(&amp;)：连接两个数值进行位运算，将数值转为二进制。对位运算，有零为零。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;<span class="comment">//（001）</span></span><br><span class="line"><span class="built_in">int</span> b=<span class="number">5</span>;<span class="comment">//（101）</span></span><br><span class="line"><span class="comment">//001</span></span><br><span class="line"><span class="comment">//101</span></span><br><span class="line"><span class="comment">//001（最终结果为1）结果小于等于最小的数</span></span><br></pre></td></tr></table></figure>

<p>位或(|)：连接两个数值进行位运算，将数值转为二进制。对位运算，有一为一。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;<span class="comment">//(001)</span></span><br><span class="line"><span class="built_in">int</span> b=<span class="number">3</span>;<span class="comment">//(011)</span></span><br><span class="line"><span class="comment">//001</span></span><br><span class="line"><span class="comment">//011</span></span><br><span class="line"><span class="comment">//011(最终结果为3)结果大于等于最大的数</span></span><br></pre></td></tr></table></figure>

<p>异或(^)：连接两个数值进行位运算，将数值转为二进制。对位运算，相同为零，不同为一。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">1</span>;<span class="comment">//(001)</span></span><br><span class="line"><span class="built_in">int</span> b=<span class="number">5</span>;<span class="comment">//(101)</span></span><br><span class="line"><span class="comment">//001</span></span><br><span class="line"><span class="comment">//101</span></span><br><span class="line"><span class="comment">//100(结果为4)</span></span><br></pre></td></tr></table></figure>

<p>位取反(~)：写在数值前面，零变一，一变零。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">5</span>;<span class="comment">//(101)</span></span><br><span class="line"><span class="comment">//~a==2(010);</span></span><br></pre></td></tr></table></figure>

<p>左移(&lt;&lt;)和右移(&gt;&gt;)：让一个二进制的数左移或右移。</p>
<p>左移几位，右边多加几个零。</p>
<p>右移几位，右侧去掉几个数。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="built_in">int</span> i=r.Next(a,b);<span class="comment">//生成随机数[a,b)的随机数赋值给i</span></span><br></pre></td></tr></table></figure>

<h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>被命名的整型常量的集合，一般用它来表示状态，类型等等。通常和switch语句搭配使用</p>
<p>声明枚举：创建一个自定义的枚举类型。（枚举可以声明在namespace语句块中,也可以声明在class和struct语句中，不能在函数语句块中声明）</p>
<p>声明枚举变量：使用自定义的枚举类型，创建一个枚举变量。</p>
<p>类型转换用强制转换。用tosString（）;转成枚举项的名字。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_自定义枚举名<span class="comment">//以E或E_开头,作为命名规范</span></span><br><span class="line">&#123;</span><br><span class="line">    自定义枚举项名字,<span class="comment">//可以自己赋值,为整型变量</span></span><br><span class="line">    自定义枚举项名字<span class="number">1</span>,<span class="comment">//这项的值为上一项加一,下同</span></span><br><span class="line">    ...</span><br><span class="line">    自定义枚举项名字n</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line">eg:</span><br><span class="line"><span class="built_in">enum</span> E_player</span><br><span class="line">&#123;</span><br><span class="line">    main,</span><br><span class="line">    other</span><br><span class="line">&#125;<span class="comment">//声明枚举</span></span><br><span class="line">E_player playertype=E_player.mian;<span class="comment">//声明枚举变量</span></span><br><span class="line">playertype=(E_player)Enum.Parse(<span class="keyword">typeof</span>(E_player),<span class="string">&quot;枚举项名称&quot;</span>);<span class="comment">//字符串转成枚举</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>语法：变量类型 []变量名&#x3D;new 变量类型[数组大小]{这里可以赋值};(默认初始化为零)&#x2F;&#x2F;一维数组</p>
<p>变量类型[,]变量名&#x3D;new 变量类型[行数,列数];&#x2F;&#x2F;二维数组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> N=<span class="number">100</span>；</span><br><span class="line"><span class="built_in">int</span>[] a=<span class="keyword">new</span> <span class="built_in">int</span>[N]&#123;此处可以赋值&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="built_in">int</span>[,] a=<span class="keyword">new</span> <span class="built_in">int</span> [<span class="number">3</span>,<span class="number">3</span>]&#123;此处可以赋值&#125;;<span class="comment">//二维数组 </span></span><br><span class="line">Console.WriteLine(a.GetLength(<span class="number">0</span>);<span class="comment">//得到二维数组行的长度</span></span><br><span class="line">Console.WriteLine(a.GetLength(<span class="number">1</span>);<span class="comment">//得到二维数组列的长度</span></span><br></pre></td></tr></table></figure>

<h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p>语法：变量类型 [] []变量名&#x3D;new 变量类型[] []</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int [][]arr=new int[3][]&#123;new int[3]&#123;1,2,3&#125;,new int[2]&#123;1,2&#125;,new int[1]&#123;1&#125;&#125;;</span><br><span class="line">int [][]arr=new int[][]&#123;new int[3]&#123;1,2,3&#125;,new int[2]&#123;1,2&#125;,new int[1]&#123;1&#125;&#125;;</span><br><span class="line">int [][]arr=&#123;new int[3]&#123;1,2,3&#125;,new int[2]&#123;1,2&#125;,new int[1]&#123;1&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h1><p>引用类型：string,数组,类</p>
<p>值类型：其它,结构体</p>
<p>引用类型和值类型存储的内存区域不相同,存储方式也不同。</p>
<p>值类型存储在栈上,系统分配,自动回收,小而快。</p>
<p>引用类型存储在堆空间,手动申请和释放,大而慢。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics.CodeAnalysis;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 测试程序</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> b = a;</span><br><span class="line">            <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">            <span class="built_in">int</span>[] arr2 = arr;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a的值为&#123;0&#125;,b的值为&#123;1&#125;&quot;</span>,a,b);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arr[0]的值为&#123;0&#125;，arr2[0]的值为&#123;1&#125;&quot;</span>,arr[<span class="number">0</span>], arr2[<span class="number">0</span>]);</span><br><span class="line">            b = <span class="number">20</span>;</span><br><span class="line">            arr2[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;修改之后的值为:&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a的值为&#123;0&#125;,b的值为&#123;1&#125;&quot;</span>, a, b);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arr[0]的值为&#123;0&#125;，arr2[0]的值为&#123;1&#125;&quot;</span>, arr[<span class="number">0</span>], arr2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//a的值为10,b的值为10</span></span><br><span class="line"><span class="comment">//arr[0]的值为1，arr2[0]的值为1</span></span><br><span class="line"><span class="comment">//修改之后的值为:</span></span><br><span class="line"><span class="comment">//a的值为10,b的值为20</span></span><br><span class="line"><span class="comment">//arr[0]的值为9，arr2[0]的值为9</span></span><br></pre></td></tr></table></figure>

<h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>虽然是引用类型,却不遵循引用类型的赋值方式,一般情况下引用类型赋值会把地址赋值给新变量,修改变量值时会直接修改地址内存内存储的值,但是string类型在赋值时会新开辟一段内存存储,使变量名指向新的地址,和值类型类似。</p>
<h2 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h2><p>可以在函数内部改变外部传入的内容，类似于c++中的引用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Specialized;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel.Design;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics.CodeAnalysis;</span><br><span class="line"><span class="keyword">using</span> System.Reflection.Metadata.Ecma335;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 测试程序</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changevaule</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changearr</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span>[]arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">            Console.WriteLine(arr[<span class="number">1</span>]);</span><br><span class="line">            changearr(<span class="keyword">ref</span> arr);</span><br><span class="line">            Console.WriteLine(arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//本来new是会新开辟一段内存,但用了ref之后,则会修改原来地址的值</span></span><br><span class="line"><span class="comment">//ref和out的用法一样,ref传入的变量必须初始化,out不用</span></span><br><span class="line"><span class="comment">//out传入的变量必须在内部赋值,ref不用,并且out传入的的变量必须在函数内部赋值,ref则不一定</span></span><br></pre></td></tr></table></figure>

<h2 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h2><p>变长参数关键字:params</p>
<p>变长参数只能是函数的最后一个参数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 测试程序</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[]arr</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.Length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">speak</span>(<span class="params"><span class="built_in">string</span> str=<span class="string">&quot;hello&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> ans = Sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">            Console.WriteLine(ans);<span class="comment">//结果为28</span></span><br><span class="line">            speak();<span class="comment">//可以不传参数,打印出默认值,有可选参数和普通参数的情况下可选参数要放后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>构造函数:函数名与结构体名相同,没有返回值,this关键字使用this.和class不相同。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">student s1=<span class="keyword">new</span> student(<span class="comment">//参数);</span></span><br><span class="line">    <span class="keyword">namespace</span> 测试程序</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">struct</span> student</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="built_in">int</span> age;</span><br><span class="line">            <span class="built_in">string</span> name;</span><br><span class="line">            <span class="built_in">bool</span> sex;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">student</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                age = <span class="number">114514</span>;</span><br><span class="line">                name = <span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">                sex = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>()</span></span><br><span class="line">                &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;我叫&#123;0&#125;,我是&#123;1&#125;性,今年&#123;2&#125;岁&quot;</span>,name,sex?<span class="string">&#x27;男&#x27;</span>:<span class="string">&#x27;女&#x27;</span>,age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            student s1=<span class="keyword">new</span> student();</span><br><span class="line">            s1.speak();</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>三大特性：封装、继承、多态</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类一般声明在namespace语句块中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类声明的语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">type</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//成员属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数和析构函数</span></span><br><span class="line">    <span class="comment">//索引器</span></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="comment">//静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子（形容人类）</span></span><br><span class="line"><span class="comment">//类用帕斯卡命名法</span></span><br><span class="line"><span class="comment">//同一个语句块中的不同类不能重名</span></span><br><span class="line"><span class="comment">//类创建的过程叫做实例化对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//实例化对象的基本语法</span></span><br><span class="line">    <span class="comment">//类名 变量名;</span></span><br><span class="line">    <span class="comment">//类名 变量名=null;</span></span><br><span class="line">    <span class="comment">//类名 变量名=new 类名();</span></span><br><span class="line">&#125;</span><br><span class="line"> Person p;</span><br><span class="line">    Person p2=<span class="literal">null</span>;</span><br><span class="line">    Person p3=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本规则</span></span><br><span class="line"><span class="comment">//声明在类语句块中</span></span><br><span class="line"><span class="comment">//用来描述对象的特征</span></span><br><span class="line"><span class="comment">//可以是任意变量类型</span></span><br><span class="line"><span class="comment">//数量不做限制</span></span><br><span class="line"><span class="comment">//是否赋值根据需求决定</span></span><br><span class="line"><span class="built_in">enum</span> E_Animal</span><br><span class="line">&#123;</span><br><span class="line">    dog,</span><br><span class="line">    cat,</span><br><span class="line">    bird</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    E_Animal type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> E_SexType</span><br><span class="line">&#123;</span><br><span class="line">    Man,</span><br><span class="line">    Woman</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="built_in">string</span> name=<span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    E_SexType sex;</span><br><span class="line">    Person grilFriend;</span><br><span class="line">    <span class="comment">//朋友</span></span><br><span class="line">    Person[] boyfriend;</span><br><span class="line">    Pet pet=<span class="keyword">new</span> Pet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问修饰符</span></span><br><span class="line"><span class="comment">//public:公共的,内部和外部都能访问</span></span><br><span class="line"><span class="comment">//private:私有的,只有类内部可以使用</span></span><br><span class="line"><span class="comment">//protect:保护的,类和其子类才能访问和使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的使用和初始值</span></span><br><span class="line"><span class="literal">default</span>(类型名);<span class="comment">//得到该类型的默认值</span></span><br></pre></td></tr></table></figure>

<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>别加static关键字</p>
<p>用法跟函数类似</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员方法(函数)用来表现对象行为</span></span><br><span class="line"><span class="comment">//描述对象行为</span></span><br><span class="line"><span class="comment">//受到访问修饰符规则影响</span></span><br><span class="line"><span class="comment">//方法数量不受限制</span></span><br><span class="line"><span class="comment">//返回值参数不做限制</span></span><br><span class="line"><span class="comment">//不要加static关键字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构造、析构、垃圾回收"><a href="#构造、析构、垃圾回收" class="headerlink" title="构造、析构、垃圾回收"></a>构造、析构、垃圾回收</h2><p>构造函数：在实例化对象时，会调用的用于初始化的函数，如果不写，默认存在一个无参构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法</span></span><br><span class="line"><span class="comment">//没有返回值</span></span><br><span class="line"><span class="comment">//函数名和类名必须相同</span></span><br><span class="line"><span class="comment">//没有特殊需求，默认是public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="comment">//类中允许无参构造函数</span></span><br><span class="line">    <span class="comment">//结构体中不允许</span></span><br><span class="line">    <span class="comment">//可以重载构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        name=<span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">        age=<span class="number">114514</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this是防止形参和类中实参冲突用的</span></span><br><span class="line">        <span class="comment">//写了this表示是指类中的成员变量，不是传进来的形式参数</span></span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age</span>):<span class="title">this</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">//这种写法会调用无参构造函数，再调用此函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age</span>):<span class="title">this</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这种写法会执行只含有name参数的构造函数，也就是上面的函数，再执行此函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this()里头也可以写常量，会先调用参数为该常量类型的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数：但引用类型的堆内存被回收时，会调用该函数</p>
<p>&#x2F;&#x2F;对于需要手动管理内存的语言(比如c++)，需要在析构函数中做一些内存回收处理，但是c#中存在自动垃圾回收机制GC，所以几乎不会用到构造函数，在unity开发中几乎不会用到</p>
<p>语法：~类名()</p>
<p>{</p>
<p>}</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>先放一边，之后再补</p>
<h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>基本概念：用于保护成员变量，为成员属性的获取和复制添加逻辑处理，解决3p的局限性，属性可以让成员变量在外部只能获取，不能修改或者是只能修改不能获取。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">get</span>&#123;&#125;</span><br><span class="line"><span class="keyword">set</span>&#123;&#125;</span><br><span class="line"><span class="comment">//get和set前面是可以加访问修饰符的,默认是public</span></span><br><span class="line"><span class="comment">//因为这种特性,所以在外部可以只赋值或者只返回值,可以保护数据</span></span><br><span class="line"><span class="comment">//属性本身的访问修饰符权限大于get和set</span></span><br><span class="line"><span class="comment">//get和set可以只有一个，一般只会出现只有get的情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> sex;</span><br><span class="line">    <span class="comment">//属性的命名一般使用帕斯卡命名法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="comment">//可以在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">//意味着这个属性可以获取的内容</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可以在设置之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">//value用于表示外部传入的值</span></span><br><span class="line">            name=<span class="keyword">value</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Money</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//解密处理</span></span><br><span class="line">            <span class="keyword">return</span> money<span class="number">-5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//加密处理</span></span><br><span class="line">            money=<span class="keyword">value</span>+<span class="number">5</span>;</span><br><span class="line">            <span class="comment">//内存里存储的不是实际值，但是返回的是实际值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Height</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">        <span class="comment">//只能在内部改</span></span><br><span class="line">        <span class="comment">//自动属性</span></span><br><span class="line">        <span class="comment">//作用:外部能得不能改的特征</span></span><br><span class="line">        <span class="comment">//如果类中有一个特征是只希望外部能得不能改的，又没什么特殊处理(没有在get和set中写逻辑的需求和想         法)，那么可以直接使用自动属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员属性的使用</span></span><br><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p.Name=<span class="string">&quot;田鼠浩二&quot;</span>;<span class="comment">//这里执行的是set语句块,将&quot;田鼠浩二&quot;赋值给name</span></span><br><span class="line">Console.Write(p.Name);<span class="comment">//执行的是get语句块，返回了name的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>基本概念：让对象想数组一样通过索引访问其中元素，是程序看起来更直观，更容易编写（就是专门用来访问类中数组的，类似于cpp中的运算符重载）,和函数写法类似，只是把括号改成中括号</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="comment">//访问修饰符 返回值 this[参数类型 参数名,参数类型 参数名...]</span></span><br><span class="line"><span class="comment">//内部写法和规则和成员属性相同</span></span><br><span class="line"><span class="comment">//get&#123;&#125;</span></span><br><span class="line"><span class="comment">//set&#123;&#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> strint name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//value代表传入的值</span></span><br><span class="line">            friends[index]=<span class="keyword">value</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p[<span class="number">0</span>]=<span class="keyword">new</span> Person();<span class="comment">//相当于访问了set方法</span></span><br><span class="line">Console.Write(p[<span class="number">0</span>]);<span class="comment">//相当于访问了get方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引器可以重载</span></span><br><span class="line"><span class="comment">//索引器的主要作用</span></span><br><span class="line"><span class="comment">//可以让我们一种括号的形式范围自定义类中的元素</span></span><br><span class="line"><span class="comment">//比较适用于 在类中有数组变量时使用 可以方便访问和逻辑处理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态关键字 static</span></span><br><span class="line"><span class="comment">//用static修饰的成员变量 方法 属性等</span></span><br><span class="line"><span class="comment">//称为静态成员</span></span><br><span class="line"><span class="comment">//特点：直接用类名点出使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> PI=<span class="number">3.1415926f</span>;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> testInt=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//静态成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CalcCircle</span>(<span class="params"><span class="built_in">float</span> r</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PI*r*r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.Write(Test.PI);<span class="comment">//可以直接用类名点成员来使用，不用先创建对象，不用实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么可以直接点出来使用</span></span><br><span class="line"><span class="comment">//程序开始运行时，就会分配内存空间，所以我们就能直接使用</span></span><br><span class="line"><span class="comment">//静态成员和程序同生共死</span></span><br><span class="line"><span class="comment">//只要使用了它，直到程序结束时内存空间才会被释放</span></span><br><span class="line"><span class="comment">//静态成员存储在静态存储区，具有唯一性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态函数中不能使用非静态成员</span></span><br><span class="line"><span class="comment">//非静态函数可以使用静态成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员的作用</span></span><br><span class="line"><span class="comment">//常用于唯一变量的申明</span></span><br><span class="line"><span class="comment">//方便别人获取的对象申明</span></span><br><span class="line"><span class="comment">//静态方法：</span></span><br><span class="line"><span class="comment">//常用的唯一的方法申明 比如 相同规则的数学计算相关函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量和静态变量</span></span><br><span class="line"><span class="comment">//const可以理解为特殊的static</span></span><br><span class="line"><span class="comment">//相同点</span></span><br><span class="line"><span class="comment">//都可以通过类名点出来使用</span></span><br><span class="line"><span class="comment">//不同点</span></span><br><span class="line"><span class="comment">//const必须初始化，不能像static没用这个规则</span></span><br><span class="line"><span class="comment">//const只能修饰变量，static可以修饰很多</span></span><br><span class="line"><span class="comment">//const一定是写在访问修饰符的后面的，static没有这个要求</span></span><br></pre></td></tr></table></figure>

<h2 id="静态类和静态构造函数（工具类）"><a href="#静态类和静态构造函数（工具类）" class="headerlink" title="静态类和静态构造函数（工具类）"></a>静态类和静态构造函数（工具类）</h2><p>用static修饰的类，特点：只能包含静态成员，不能被实例化。作用：将常用的静态成员写在静态类中，方便使用，静态类不能被实例化，体现了工具类的唯一性，比如Console就是一个静态类。</p>
<p>静态构造函数：特点：静态类和普通类都可以有，不能使用访问修饰符，不能有参数，只会调用一次</p>
<p>作用：在静态构造函数中初始化 静态变量</p>
<p>使用：静态类中的静态构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TestStatic</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testIndex=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> TestIndex</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">get</span>;</span><br><span class="line">         <span class="keyword">set</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态类中的静态构造函数(使用类中内容会自动调用静态构造函数)</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticClass</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="title">StaticClass</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;静态构造函数&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类中的静态构造函数(使用类中内容会自动调用静态构造函数)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> testInt=<span class="number">200</span>;</span><br><span class="line">    <span class="comment">//静态构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;静态构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态构造函数(不是重载)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;普通构造&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><p>基本概念：为现有的 非静态 变量类型 添加新方法，作用：提升程序拓展性，不需要在对象中重新写方法，不需要继承来添加方法，为别人封装的类型写额外的方法。</p>
<p>特点：一定是写在静态类中，一定是一个静态函数，第一个参数为拓展目标，第一个参数用this修饰</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="comment">//访问修饰符 static 返回值 函数名(this 拓展类名 参数名,参数类型 参数名，参数类型 参数名，参数类型 参数名...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为interesting拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//成员方法需要实例化对象后才能使用</span></span><br><span class="line">    <span class="comment">//value代表使用该方法的实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)<span class="comment">//这里的value是int类型变量本身的值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;田鼠浩二为int拓展的方法&quot;</span>+<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Fun3</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为Test拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">int</span> i=<span class="number">10</span>;</span><br><span class="line">i.SpeakValue();</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//田鼠浩二为int拓展的方法10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义的类拓展方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">t.Fun3();</span><br><span class="line"><span class="comment">//如果拓展方法和类中方法重名了，比如将Fun3改名为Fun2，那么将会执行类中的方法而拓展方法将会失效。</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>概念：让自定义类和结构体能够使用运算符</p>
<p>使用关键字 operator</p>
<p>特点：一定是一个公共的静态方法，返回值卸载operator前，逻辑处理自定义</p>
<p>作用：让自定义类和结构体对象可以进行运算，条件运算符需要成对实现，一个符号可以多个重载，不能使用ref和out（相当于自定义一种运算方式）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1,Point p2)</span><br><span class="line">        &#123;</span><br><span class="line">            Point p=<span class="keyword">new</span> Point();</span><br><span class="line">            p.x=p1.x+p2.x;</span><br><span class="line">            p.y=p1.y+p2.y;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个符号可以有多个重载</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1,<span class="built_in">int</span> <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Point p=<span class="keyword">new</span> Point();</span><br><span class="line">            p.x=p1.x+<span class="keyword">value</span>;</span><br><span class="line">            p.y=p1.y+<span class="keyword">value</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Point p1=<span class="keyword">new</span> Point();</span><br><span class="line">p1.x=<span class="number">1</span>;</span><br><span class="line">p1.y=<span class="number">1</span>;</span><br><span class="line">Point p2=<span class="keyword">new</span> Point();</span><br><span class="line">p2.x=<span class="number">2</span>;</span><br><span class="line">p2.y=<span class="number">2</span>;</span><br><span class="line">Point p3=p1+p2;</span><br><span class="line">Point p4=p3+<span class="number">2</span>;<span class="comment">//不能写成p4=2+p3，有顺序，如果要写，要重写一个重载</span></span><br></pre></td></tr></table></figure>

<p>可重载的运算符：算术运算符，逻辑运算符（只有非!），位运算符，条件运算符（需要成对实现，重载了大于就要重载小于）</p>
<p>不可重载的运算符：逻辑与，逻辑或，索引符，强转运算符，特殊运算符，点，三目运算符，赋值符号</p>
<h2 id="内部类和分布类"><a href="#内部类和分布类" class="headerlink" title="内部类和分布类"></a>内部类和分布类</h2><p>内部类：一个类中再申明一个类</p>
<p>特点：使用时要用包裹者点出自己</p>
<p>作用：亲密关系的变现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> Body body;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Body</span></span><br><span class="line">    &#123;</span><br><span class="line">        Arm leftArm;</span><br><span class="line">        Arm rightArm;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Arm</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">Person.Body body=<span class="keyword">new</span> Person.Body();</span><br><span class="line">Person.Arm</span><br></pre></td></tr></table></figure>

<p>分布类：把一个类分成几部分申明</p>
<p>关键字：partial</p>
<p>作用：分布描述一个类，增加程序的拓展性。（可以写在多个脚本文件中，分布类的访问修饰符要一致，不能有重复成员）其实就是把一个类分成好几个语句块中写。</p>
<p>分部方法：将方法的申明和实现分离</p>
<p>特点：不能加访问修饰符（默认私有），只能在分布类中申明，返回值只能是void，可以有参数但不用，out关键字，局限性大，了解即可。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h2><p>基本概念：一个类a继承一个类b，类a会继承类b的所有成员，a类将拥有类b的所有特征和行为。</p>
<p>被继承的类叫做父类、基类、超类。继承的类叫做子类、派生类。子类可以有自己的特征和行为。</p>
<p>特点：单根性 子类只能有一个父亲。传递性 子类可以间接继承父类的父亲（类似于树状结构）</p>
<p>c#中允许父类和子类同名的成员，但不建议使用（会覆盖父类的同名成员）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="comment">//class 类名 : 被继承的类名</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//职工号</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> number;<span class="comment">//如果这里使用private则外部无法使用，protected子类可以使用</span></span><br><span class="line">    <span class="comment">//介绍名字的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class TeachingTeacher:Teacher</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//科目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">    <span class="comment">//介绍科目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakSubject</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(subject+<span class="string">&quot;老师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TeachingTeacher tt=<span class="keyword">new</span> TeachingTeacher();</span><br><span class="line">tt.name=<span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">tt.number=<span class="number">1</span>;</span><br><span class="line">tt.SpeakName();<span class="comment">//可以使用父类的成员</span></span><br><span class="line"></span><br><span class="line">tt.subject=<span class="string">&quot;unity&quot;</span>;</span><br><span class="line">tt.SpeakSubject();</span><br></pre></td></tr></table></figure>

<h2 id="里氏替换原则（LSP）（面向对象七大原则之一）"><a href="#里氏替换原则（LSP）（面向对象七大原则之一）" class="headerlink" title="里氏替换原则（LSP）（面向对象七大原则之一）"></a>里氏替换原则（LSP）（面向对象七大原则之一）</h2><p>基本概念：任何父类出现的地方，子类都可以替代。父类容器装子类对象，因为子类包含了父类的全部内容</p>
<p>作用：方便进行对象存储和管理</p>
<p>is：判断一个对象是否是指定类对象，返回值是bool，是为真，不是为假。</p>
<p>as：将一个对象转换为指定类对象，返回值为指定类对象，失败返回null</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">GameObject</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerAtk</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;玩家攻击&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Monster</span> : <span class="title">GameObject</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MonsterAtk</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;怪物攻击&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Boss</span> : <span class="title">GameObject</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BossAtk</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Boss攻击&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//里氏替换原则 用父类容器装载子类对象</span></span><br><span class="line"> GameObject player = <span class="keyword">new</span> Player();</span><br><span class="line"> GameObject monster = <span class="keyword">new</span> Monster();</span><br><span class="line"> GameObject boss = <span class="keyword">new</span> Boss();</span><br><span class="line"></span><br><span class="line"> GameObject[] objects = <span class="keyword">new</span> GameObject[] &#123; <span class="keyword">new</span> Player,<span class="keyword">new</span> Monster,<span class="keyword">new</span> Boss&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(player <span class="keyword">is</span> Player)<span class="comment">//如果是真的话会返回真，否则返回假</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Player p=player <span class="keyword">as</span> Player;</span><br><span class="line">Player p=monster <span class="keyword">as</span> Player;</span><br></pre></td></tr></table></figure>

<h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p>特点：当申明一个子类对象时，先执行父类的构造函数，再执行子类的构造函数</p>
<p>父类的无参构造函数很重要。子类可以通过base关键字代表父类，调用父类构造函数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>()<span class="comment">//没有这个子类会报错</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Father构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span>:<span class="title">Father</span><span class="comment">//父类没有无参构造函数会报错（无参构造函数被顶替了）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i</span>):<span class="title">base</span>(<span class="params">i</span>)<span class="comment">//通过base调用指定父类构造</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span>(<span class="params"><span class="built_in">int</span> i,<span class="built_in">string</span> str</span>):<span class="title">this</span>(<span class="params">i</span>)<span class="comment">//通过this先调用上面的构造函数，间接指定了父类的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//子类实例化默认自动调用的是父类的无参构造函数</span></span><br></pre></td></tr></table></figure>

<h2 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h2><p>关键字：object，概念：是所有类型的父类，是一个类（引用类型），作用：可以利用里氏替换原则，用object容器装所有对象，可以用来表示不确定类型，作为函数参数类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span>:<span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father f=<span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">if</span>(f <span class="keyword">is</span> Son)</span><br><span class="line">&#123;</span><br><span class="line">    (f <span class="keyword">as</span> Son).Speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> o=<span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">is</span> Son)</span><br><span class="line">&#123;</span><br><span class="line">    (o <span class="keyword">as</span> Son).Speak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//值类型</span></span><br><span class="line"><span class="built_in">object</span> o2=<span class="number">1f</span>;</span><br><span class="line"><span class="comment">//用强转</span></span><br><span class="line"><span class="built_in">float</span> f1=(<span class="built_in">float</span>)o2;</span><br><span class="line"><span class="comment">//特殊的string类型</span></span><br><span class="line"><span class="built_in">object</span> str=<span class="string">&quot;123123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2=str <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> []ar=arr <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱拆箱</span></span><br><span class="line"><span class="comment">//发生条件</span></span><br><span class="line"><span class="comment">//用object存储类型（装箱）</span></span><br><span class="line"><span class="comment">//再把object转为值类型（拆箱）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line"><span class="comment">//把值类型用引用类型存储</span></span><br><span class="line"><span class="comment">//栈内存会迁移到堆内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="comment">//把引用类型存储的值类型取出来</span></span><br><span class="line"><span class="comment">//堆内存会迁移到栈内存中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//好处：不确定类型可以方便参数的存储和传递</span></span><br><span class="line"><span class="comment">//坏处：存在内存迁移，增加性能消耗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line"><span class="built_in">object</span> v=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="built_in">int</span> inValue=(<span class="built_in">int</span>)v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] array</span>)<span class="comment">//将int换成object就可以传任意类型（传不确定类型）</span></span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="密封类（不是很重要）"><a href="#密封类（不是很重要）" class="headerlink" title="密封类（不是很重要）"></a>密封类（不是很重要）</h2><p>概念：使用sealed密封关键字修饰的类</p>
<p>作用：让类无法再被继承</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Son</span>:<span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这个类无法被继承    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要作用：不允许最底层子类被继承</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态vob"><a href="#多态vob" class="headerlink" title="多态vob"></a>多态vob</h2><p>多态：多种状态，让继承同一父类的子类们，在执行相同方法时有不同的表现，解决的问题：让同一个对象有唯一行为的特征。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeakName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span>:<span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">SpeakName</span>()<span class="comment">//覆盖父类的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father f=<span class="keyword">new</span> Son();</span><br><span class="line">f.SpeakName();<span class="comment">//执行了父类的方法，用了父类容器</span></span><br><span class="line">(f <span class="keyword">as</span> Son).SpeakName();<span class="comment">//执行了子类的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的实现</span></span><br><span class="line"><span class="comment">//函数重载是编译时的多态，开始就写好的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们学习的是运行时多态（vob、抽象函数、接口）</span></span><br><span class="line"><span class="comment">//v:virtual（虚函数）</span></span><br><span class="line"><span class="comment">//o:override(重写）</span></span><br><span class="line"><span class="comment">//b:base(父类)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;游戏对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span>:<span class="title">GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//base的作用</span></span><br><span class="line">        <span class="comment">//代表父类 可以通过base来保留父类的行为,如果写了base父类的同名函数也会执行</span></span><br><span class="line">        <span class="keyword">base</span>.Atk();</span><br><span class="line">        console.WriteLine(<span class="string">&quot;让玩家对象进行攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使使用了父类容器装载子类的实例化对象，但是通过重写之后可以直接使用子类的同名函数，不需要通过as进行转化了</p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>抽象类</p>
<p>概念：被抽象关键字abstract修饰的类，特点：不能被实例化，可以包含抽象方法，继承抽象类必须重写其抽象方法</p>
<p>抽象函数</p>
<p>又叫纯虚方法，用abstract修饰的方法，特点：只能在抽象类中申明，没有方法体，不能是私有的，继承后必须要实现，用override重写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Thing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抽象类中 封装的所有知识点都可以在其中书写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以在抽象类中写抽象函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Water</span>:<span class="title">Thing</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不能被实例化</span></span><br><span class="line">Thing t=<span class="keyword">new</span> Water();<span class="comment">//遵循里氏替换原则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Fruits</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Bad</span>()</span>;<span class="comment">//必须继承过后实现，不能是私有的，没有方法体,c++中的纯虚函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//虚方法可以选择是否写逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Apple</span>:<span class="title">Fruits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bad</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="comment">//虚方法是可以由我们子类选择性来实现的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SuperApple</span>:<span class="title">Apple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//虚方法和抽象方法都可以被子类无限重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bad</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>概念：是行为的抽象规范，是一种自定义类型，关键字：interface</p>
<p>接口申明的规范：不包含成员变量，只包含方法、属性、索引器、事件，成员不能被实现，成员可以不用写访问修饰符，不能是私有的，接口不能继承类，但是可以继承另一个接口</p>
<p>接口的使用规范：类可以继承多个接口，类继承接口后，必许实现接口中的所有成员</p>
<p>特点：和类的声明类似，接口是用来继承的，接口不能被实例化，但是可以作为容器存储对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口关键字：interface</span></span><br><span class="line"><span class="comment">//语法：</span></span><br><span class="line"><span class="comment">//interface 接口名</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//接口是抽象行为的“基类”</span></span><br><span class="line"><span class="comment">//使用帕斯卡命名法，但是前面加个I</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;<span class="comment">//不需要方法体，不能加私有，不然违反实现接口中的所有成员</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">string</span> Nmae<span class="comment">//属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;<span class="comment">//get和set也不能有语法快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]<span class="comment">//索引器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">event</span> Action doSomething<span class="comment">//事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="comment">//基类</span></span><br><span class="line"><span class="comment">//类可以继承一个类和多个接口</span></span><br><span class="line"><span class="comment">//继承了接口后，必须实现其中的内容，并且必须是public的</span></span><br><span class="line"><span class="comment">//接口成员若在内部实现，则在外部不能被实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>:<span class="title">Animal</span>,<span class="title">IFly</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fly</span>()<span class="comment">//让子类可以重写这个函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span> [<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action doSomething;   </span><br><span class="line">&#125;<span class="comment">//继承一个类和一个接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现的接口函数，可以加virtual再在子类中重写</span></span><br><span class="line"><span class="comment">//接口也遵循里氏替换原则</span></span><br><span class="line"></span><br><span class="line">IFly f=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口的主要作用：类似于行为的多态，可以为不同种对象但是又有相同行为的对象提供方法</p>
<p>接口可以继承接口，不需要去实现，待类继承接口后，类自己去实现所有内容。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式实现接口</span></span><br><span class="line"><span class="comment">//当一个类继承两个接口</span></span><br><span class="line"><span class="comment">//但是接口中存在着同名方法时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Atk</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Player</span>:<span class="title">IAtk</span>,<span class="title">ISuperAtk</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//显示实现接口，用接口名加行为名实现，主要用于不同接口之间同名函数的不同表现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> IAtk.Atk()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ISuperAtk</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>抽象类和抽象方法：abstract修饰的类和方法，抽象类不能实例化，抽象方法只能在抽象类中申明，是纯虚方法，必须在子类中实现。</p>
<p>接口：interface 自定义类型，是行为的抽象，不包含成员变量，仅包含方法，属性，索引器，事件，成员都不能是实现，建议不写访问修饰符，默认public</p>
<p>相同点：都可以被继承，都不能直接实例化，都可以包含方法申明，子类必须实现未实现的方法，都遵循里氏替换原则。</p>
<p>不同点：抽象类中可以有构造函数，接口中不能，抽象类只能被单一继承，接口可以被继承多个，抽象类中可以有成员变量，接口中不能，抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口只能申明没有实现的抽象方法，抽象类方法可以使用访问修饰符，接口中建议不写，默认public</p>
<p>使用：表示对象的用抽象类，表示行为拓展的用接口，不同对象拥有的共同行为，我们往往可以使用接口来实现</p>
<h2 id="密封函数（不是很重要）"><a href="#密封函数（不是很重要）" class="headerlink" title="密封函数（不是很重要）"></a>密封函数（不是很重要）</h2><p>概念：用密封关键字sealed修饰的重写函数，作用：让虚方法或者抽象方法之后不能再被重写，特点：和override一起出现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">WhitePerson</span>:<span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">base</span>.Eat();    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Speak();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>:<span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Eat</span>()<span class="comment">//加了sealed之后这个方法在之后的子类中无法被继承，如上面的</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>概念：命名空间是用来组织和重用代码的，作用：就像是一个工具包，类就像是一件件的工具，都是申明在命名空间里的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//类</span></span><br><span class="line">    <span class="comment">//类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">GameObject</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyGame</span><span class="comment">//可以直接分开写，和上面的命名空间是同一个</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Player</span>:<span class="title">GameObject</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> 命名空间名<span class="comment">//引用命名空间写最上面</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//不同命名空间允许有同名类</span></span><br><span class="line"><span class="comment">//使用同名类的话要点出命名空间名</span></span><br><span class="line"><span class="comment">//命名空间可以包裹命名空间</span></span><br><span class="line"><span class="comment">//如果直接引用了最外面的类，那么被包裹的的命名空间的类将不能被使用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//关于修饰类的访问修饰符</span></span><br><span class="line"><span class="comment">//internal 只能在该程序集中使用 命名空间中的类默认为internal，本地的</span></span><br><span class="line"><span class="comment">//abstract 抽象类</span></span><br><span class="line"><span class="comment">//sealed 密封类</span></span><br><span class="line"><span class="comment">//partial 分布类    </span></span><br></pre></td></tr></table></figure>



<h2 id="万物之父中的方法"><a href="#万物之父中的方法" class="headerlink" title="万物之父中的方法"></a>万物之父中的方法</h2><p>object中的静态方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Equals 判断两个对象是否相等</span></span><br><span class="line"><span class="comment">//最终的判断权，交给左侧对象的Equals方法</span></span><br><span class="line"><span class="comment">//不管值类型引用类型都会按照左侧Equals方法的规则来进行比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">Test t2=<span class="keyword">new</span> Test();</span><br><span class="line">Object.Equals(t,t2);<span class="comment">//返回值为false，因为二者的地址不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//referenceEquals 比较两个对象是否是相同的引用，主要是用来比较引用类型的对象</span></span><br><span class="line">Object.referenceEquals(t2,t)<span class="comment">//返回的也是false，专门用来比引用的东西</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>object中的成员方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方法GetType</span></span><br><span class="line"><span class="comment">//该方法在反射中是非常重要的方法</span></span><br><span class="line"><span class="comment">//主要作用是获取对象运行时的type</span></span><br><span class="line"></span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">Type type =t.GetType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通方法MemberwiseClone</span></span><br><span class="line"><span class="comment">//该方法用于获取对象的浅拷贝对象，口语化的意思就是会返回一个新的对象</span></span><br><span class="line"><span class="comment">//但是新对象中的引用变量会和老对象中的一致</span></span><br><span class="line"><span class="comment">//类似于as关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> Test2 t2=<span class="keyword">new</span> Test();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Test <span class="title">clone</span>()<span class="comment">//因为MemberwiseClone的访问修饰符为protected，无法在外部调用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MemberwiseClone() <span class="keyword">as</span> Test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t2=t.Clone();<span class="comment">//得到个新地址，里头的值类型地址发生了改变，里头的引用类型的地址和t完全一致</span></span><br><span class="line">Console.WriteLine(t.i);</span><br><span class="line">Console.WriteLine(t.t2.i);</span><br><span class="line">Console.WriteLine(t2.i);</span><br><span class="line">Console.WriteLine(t2.t2.i);</span><br><span class="line"></span><br><span class="line">t2.i=<span class="number">20</span>;</span><br><span class="line">t2.t2.i=<span class="number">21</span>;</span><br></pre></td></tr></table></figure>

<p> object中的虚方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚方法Equals</span></span><br><span class="line"><span class="comment">//默认实现还是比较两者是否为同一个引用，相当于ReferenceEquals。</span></span><br><span class="line"><span class="comment">//但是微软在所有值类型的父类System.ValueType中重写了该方法，用来比较值相等。</span></span><br><span class="line"><span class="comment">//我们也可以重写该方法，定义自己的比较相等的规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚方法GetHashCode</span></span><br><span class="line"><span class="comment">//该方法是获取对象的哈希码</span></span><br><span class="line"><span class="comment">//（一种通过算法算出的，表示对象的唯一编码，不同对象哈希码可能一样，具体指根据哈希算法决定）</span></span><br><span class="line"><span class="comment">//我们可以通过重写该函数来定义对象的哈希码算法，正常情况下，我们使用的极少，基本不用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//虚方法ToString</span></span><br><span class="line"><span class="comment">//该方法用于返回对象代表的字符串，我们可以重写他定义我们自己的对象转字符串规则</span></span><br><span class="line"><span class="comment">//该方法非常常用，但我们调用打印方法时，默认使用的就是对象的ToString方法后打印出的内容</span></span><br></pre></td></tr></table></figure>



<h2 id="string类型-1"><a href="#string类型-1" class="headerlink" title="string类型"></a>string类型</h2><p>字符串本质是一个char数组</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串指定位置的获取</span></span><br><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>]);<span class="comment">//打印出的是田,string类里面写了个索引器</span></span><br><span class="line"><span class="comment">//string转成char数组</span></span><br><span class="line"><span class="built_in">char</span>[]chars=str.ToCharArray();</span><br><span class="line">Console.WriteLine(chars[<span class="number">1</span>]);<span class="comment">//打印出鼠</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;str.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line">str=<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>,<span class="number">1</span>,<span class="number">3333</span>);</span><br><span class="line">console.WriteLine(str);<span class="comment">//打印出13333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正向查找字符的位置</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;我是田鼠浩二&quot;</span>;</span><br><span class="line">str.indexOf(<span class="string">&quot;田&quot;</span>);<span class="comment">//返回的是int 2（下标）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index=str.IndexOf(<span class="string">&quot;吊&quot;</span>);<span class="comment">//返回的是-1（没找到）</span></span><br><span class="line">Console.WriteLine(index);<span class="comment">//打印出的是-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反向查找字符的位置</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;我是田鼠浩二田鼠浩二&quot;</span>;</span><br><span class="line">index=str.LastIndexOf(<span class="string">&quot;田鼠浩二&quot;</span>);<span class="comment">//打印出的是6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没找到返回的是-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除指定位置后的字符</span></span><br><span class="line">str=<span class="string">&quot;我是田鼠浩二田鼠浩二&quot;</span>;</span><br><span class="line">str=str.Remove(<span class="number">4</span>);<span class="comment">//返回一个新字符串，删除了第四个位置开始（包括第四个位置）的字符串</span></span><br><span class="line">Console.WriteLine(str);<span class="comment">//我是田鼠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行两个参数移除</span></span><br><span class="line"><span class="comment">//参数一 开始位置</span></span><br><span class="line"><span class="comment">//参数二 字符个数</span></span><br><span class="line">str=str.Remove(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//返回的是 我田鼠</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换指定字符串</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;我是田鼠浩二田鼠浩二&quot;</span>;</span><br><span class="line">str=str.Replace(<span class="string">&quot;田鼠浩二&quot;</span>,<span class="string">&quot;田所浩二&quot;</span>);<span class="comment">//返回的是新字符串</span></span><br><span class="line">Console.WriteLine(str);<span class="comment">//会将所有字符串进行替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小写转换</span></span><br><span class="line">str=<span class="string">&quot;naohdflkdsafs&quot;</span>;</span><br><span class="line">str=str.ToUpper();<span class="comment">//返回新字符串</span></span><br><span class="line">Console.WriteLine(str);<span class="comment">//小写字母全转成大写</span></span><br><span class="line">str=str.ToLower();</span><br><span class="line">Console.WriteLine(str);<span class="comment">//大写字母全转成小写字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串截取</span></span><br><span class="line"><span class="comment">//截取从指定位置开始之后的字符串</span></span><br><span class="line">str=<span class="string">&quot;田鼠浩二&quot;</span>;</span><br><span class="line">str.Substring(<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(str);<span class="comment">//打印出的是浩二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line"><span class="comment">//第一个参数是位置，第二个是个数</span></span><br><span class="line">str=str.Substring(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Console.WriteLine(str);<span class="comment">//报错，长度越界了，不会自动识别越界</span></span><br><span class="line">str=str.Substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">Console.WriteLine(str);<span class="comment">//打印出的是二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串切割（较重要）</span></span><br><span class="line">str=<span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[]strs=str.Split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//传进去的是字符,将逗号进行切割</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;strs.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印出的是</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="comment">//8</span></span><br></pre></td></tr></table></figure>



<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>优势是可以预先分配内存，避免过度浪费，其他和string差不多</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string是特殊的引用</span></span><br><span class="line"><span class="comment">//每次重新赋值或者拼接都会分配新的空间</span></span><br><span class="line"><span class="comment">//如果一个字符串经常改变会非常浪费空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="comment">//c#提供的一个用于处理字符串的公共类</span></span><br><span class="line"><span class="comment">//修改字符串而不创建新的对象，可以提升性能</span></span><br><span class="line"><span class="comment">//使用时需要引用命名空间(System.Test)</span></span><br><span class="line">StringBuilder str=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;123123123&quot;</span>);</span><br><span class="line">Console.WriteLine(str);<span class="comment">//打印出123123123</span></span><br><span class="line"><span class="comment">//StringBuilder存在一个容量的问题，每次往里面增加时，会自动扩容</span></span><br><span class="line"><span class="comment">//获得容量</span></span><br><span class="line">Console.WriteLine(str.Capacity);<span class="comment">//打印出16，说明后面有多个空位</span></span><br><span class="line"><span class="comment">//每次容量越界都会乘以2，也就是容量的大小是2的指数，也会产生垃圾，但相比原来要小得多</span></span><br><span class="line"><span class="comment">//获得字符长度</span></span><br><span class="line">Console.writeLine(str.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增删查改操作</span></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">str.Append(<span class="string">&quot;3333&quot;</span>);<span class="comment">//在后面加3333</span></span><br><span class="line"></span><br><span class="line">str.AppendFormat(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>,<span class="number">100</span>,<span class="number">200</span>);<span class="comment">//也有这种拼接的形式加字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">str.Insert(<span class="number">0</span>,<span class="string">&quot;田鼠浩二&quot;</span>);<span class="comment">//位置，插入字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">str.Remove(<span class="number">0</span>，<span class="number">10</span>);<span class="comment">//位置，长度（同样要注意越界问题，不会识别越界）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">str.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">Console.WriteLine(str[<span class="number">0</span>)];</span><br><span class="line">                  </span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">str[<span class="number">0</span>]=<span class="string">&#x27;A&#x27;</span>;<span class="comment">//string的索引器是只读的，但是stringbuilder可以                  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">str.Replace(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;田&quot;</span>);<span class="comment">//被替换字符，替换字符 </span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//重新赋值</span></span><br><span class="line">str.Clear();<span class="comment">//先清空</span></span><br><span class="line">str.Append(<span class="string">&quot;123&quot;</span>);<span class="comment">//再添加    </span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">//判断相等</span></span><br><span class="line"><span class="comment">//Equals（object中的重载）</span></span><br><span class="line">str.Equals(<span class="string">&quot;123&quot;</span>)<span class="comment">//返回true                  </span></span><br></pre></td></tr></table></figure>

<h2 id="类和结构体的区别"><a href="#类和结构体的区别" class="headerlink" title="类和结构体的区别"></a>类和结构体的区别</h2><p>类是引用类型，结构体是值类型。都可以用来形容对象，结构体没有继承和多态的特性，结构体不具备继承的特性，不能用protected保护访问修饰符。结构体成员变量不能指定初始值，结构体不能申明无参的构造函数，结构体申明有参构造函数后，无参的不会被顶掉，结构体不能申明析构函数，结构体不能被静态static修饰，类可以，结构体不能在自己内部申明和自己一样的结构体变量，类可以。</p>
<p>结构体可以继承接口，因为接口是行为的抽象。</p>
<p>选择：想要用继承和多态是直接用类（比如玩家，怪物等），对象是数据集合时优先考虑结构体（比如位置，坐标等）</p>
<p>从值类型和引用类型赋值时的区别考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，用结构体，比如坐标，向量，旋转等。</p>
<h2 id="多脚本文件"><a href="#多脚本文件" class="headerlink" title="多脚本文件"></a>多脚本文件</h2><p>新建脚本文件：</p>
<p>一般一个类一个脚本，一个结构体一个脚本，一个接口一个脚本，枚举在特殊情况下也可以一个脚本。</p>
<p>在文件夹中新建脚本文件：</p>
<p>可以将相同类型的脚本放在一个文件夹中</p>
<p>c#脚本文件后缀是.cs  c#解决方案中的一些重要文件夹 如bin 解决方案资源管理器窗口 工程右键 点添加</p>
<p>文件中新建脚本文件需要注意命名空间改变</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>统一建模语言（Unified Modeling Language,UML）是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何程序设计语言。</p>
<p>使用一些高级的UML可视化软件，不用写代码，通过做一些图表相关内容就可以直接生成代码，在其基础上进行开发。他的最终目标是直接能通过图形就把业务逻辑完成</p>
<p>UML类图是UML其中很小的一部分，可以帮助我们理清对象间关系</p>
<h1 id="面向对象七大原则"><a href="#面向对象七大原则" class="headerlink" title="面向对象七大原则"></a>面向对象七大原则</h1><h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h2><p>类被修改的几率很大，因此应该专注于单一的功能。如果把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，可能终止另一个功能。例如程序，策划，美术三个工种是三个类，应该各司其职，只做自己的工作</p>
<h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h2><p>对拓展开发，对修改关闭。拓展开放：模块的行为可以被拓展从而满足新的需求  拓展关闭：不允许修改模块的源代码（或者尽量使修改最小化）继承就是最典型的开闭原则的体现，可以通过添加子类和重写父类的方法来实现。</p>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则(LSP)"></a>里氏替换原则(LSP)</h2><p>任何父类出现的地方，子类都可以替代。</p>
<h2 id="依赖倒转原则-DIP"><a href="#依赖倒转原则-DIP" class="headerlink" title="依赖倒转原则(DIP)"></a>依赖倒转原则(DIP)</h2><p>要依赖与抽象，不要依赖于具体的实现。</p>
<h2 id="迪米特原则-LoP"><a href="#迪米特原则-LoP" class="headerlink" title="迪米特原则(LoP)"></a>迪米特原则(LoP)</h2><p>最少知识原则，一个对象应当对其它对象尽可能少的了解，不要和陌生人说话。</p>
<p>一个对象的成员，要尽可能少的直接和其他类建立关系，降低耦合性</p>
<h2 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则(ISP)"></a>接口分离原则(ISP)</h2><p>不应该强迫别人依赖他们不需要使用的方法，一个接口不需要提供太多的行为，一个接口应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有行为封装到一个接口里。</p>
<h2 id="合成复用原则-CRP"><a href="#合成复用原则-CRP" class="headerlink" title="合成复用原则(CRP)"></a>合成复用原则(CRP)</h2><p>尽量使用对象组合，而不是继承来达到复用的目的，继承关系是强耦合，组合关系是低耦合，例如脸是眼睛、鼻子、嘴巴、耳朵的组合，而不是继承，角色和装备也是组合。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>本质是一个object类型的数组，在system.collections命名空间里。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ArrayList array=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">array.Add();<span class="comment">//里面放内容，因为是object类，所以可以放任何类型</span></span><br><span class="line">ArrayList array2=<span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//批量增加</span></span><br><span class="line">array.AddRange(array2);<span class="comment">//将array2的所有内容加到array中</span></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">array.Insert(<span class="number">1</span>,<span class="string">&quot;1234565&quot;</span>);<span class="comment">//第一个参数是位置下标，第二个是元素内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">array.Remove();<span class="comment">//里面写具体要删除的元素，全部元素都会被删除</span></span><br><span class="line"><span class="comment">//移除指定位置的元素</span></span><br><span class="line">array.RemoveAt(<span class="number">2</span>);<span class="comment">//写下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">array[<span class="number">0</span>];<span class="comment">//返回第一个元素，和数组相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看元素是否存在</span></span><br><span class="line">arr.Contains()<span class="comment">//里面具体写元素，存在返回true，否则返回false</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//正向查找元素位置</span></span><br><span class="line">array.IndexOf();<span class="comment">//里面具体填写要找的元素，找到返回第一个找到的下标，没找到返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反向查找元素位置</span></span><br><span class="line">array.LastIndexOf();<span class="comment">//这个是返回的是从后面找到的第一个的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">array[<span class="number">0</span>]=<span class="string">&quot;000&quot;</span>;<span class="comment">//直接赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//当前长度</span></span><br><span class="line">array.Count</span><br><span class="line"><span class="comment">//容量</span></span><br><span class="line">array.<span class="function">capacity    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="built_in">int</span> i=<span class="number">0</span>;i&lt;array,Count;i++</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> array)<span class="comment">//每次都将array中元素放入item中再操作</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱拆箱</span></span><br><span class="line"><span class="comment">//将值类型装入就是装箱，将值对象取出来转换使用就是拆箱</span></span><br><span class="line"><span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">array[<span class="number">0</span>]=i;<span class="comment">//装箱</span></span><br><span class="line">i=(<span class="built_in">int</span>)array[<span class="number">0</span>];<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>



<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈，先进后出，本质也是一个object数组，只不过封装了特殊的存储规则</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Stack stack=<span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line">stack.Push();<span class="comment">//太熟悉了.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">stack.Pop();<span class="comment">//太熟悉了.jpg,返回其中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">stack.Peek();<span class="comment">//查看栈顶，返回栈顶元素但不弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看元素是否存在于栈中</span></span><br><span class="line">stack.Contains();<span class="comment">//返回bool值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">stack.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">stack.Count</span><br><span class="line"><span class="comment">//遍历顺序:从栈顶到栈底</span></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> temp <span class="keyword">in</span> stack)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(temp);<span class="comment">//从栈顶到栈底</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历方法</span></span><br><span class="line"><span class="comment">//将栈转换为object数组</span></span><br><span class="line"><span class="built_in">object</span>[]array=stack.ToArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环弹栈</span></span><br><span class="line"><span class="keyword">while</span>(stack.Count&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> o=stack.Pop();</span><br><span class="line">    Console.WriteLine(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列，先进先出，本质也是一个object数组，只不过封装了特殊的存储规则</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Queue queue=<span class="keyword">new</span> Queue();</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue.Enqueue();<span class="comment">//不多说了，累死了</span></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">queue.Dequeue();<span class="comment">//返回队头</span></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">queue.Peek();<span class="comment">//和栈一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(queue.Contains())<span class="comment">//这个也是一样的</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//和栈还是一样</span></span><br><span class="line">queue.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">queue.Count;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> queue)<span class="comment">//万能的迭代器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种遍历和栈一样转数组，不多说了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环出列</span></span><br><span class="line"><span class="comment">//这个和栈还是一样</span></span><br><span class="line"><span class="comment">//不多说了。。。</span></span><br></pre></td></tr></table></figure>

<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>哈希表，也就是散列表，使用键来访问集合中的元素，就是c++中的map</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Hashtable hashtable=<span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">hashtable.Add(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//1是键，“123”是值</span></span><br><span class="line">hashtable.Add(<span class="string">&quot;123&quot;</span>,<span class="number">2</span>);<span class="comment">//这个&quot;123&quot;是键，2是值</span></span><br><span class="line">hashtable.Add(<span class="literal">true</span>,<span class="literal">true</span>);<span class="comment">//类似</span></span><br><span class="line"><span class="comment">//不能出现相同的键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//只能通过键去删</span></span><br><span class="line">hashtable.Remove();<span class="comment">//里面写键，删除对应的键和元素</span></span><br><span class="line"><span class="comment">//删除不存在的键没有反应，不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">hashtable.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="comment">//通过键查看值</span></span><br><span class="line"><span class="comment">//找不到返回空</span></span><br><span class="line">hashtable[键];<span class="comment">//键对应的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看是否存在</span></span><br><span class="line"><span class="comment">//根据键检测</span></span><br><span class="line">hashtable.Contain(键);<span class="comment">//返回的是bool值</span></span><br><span class="line">hashtable.ContainKey(键);<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值检测</span></span><br><span class="line">hashtable.ContainValue(值);<span class="comment">//返回的是bool值，里面写值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//只能改键对应的值内容 无法修改键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//得到对数</span></span><br><span class="line">hashtable.Count;<span class="comment">//键的对数</span></span><br><span class="line"><span class="comment">//遍历所有键</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Keys)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);<span class="comment">//键</span></span><br><span class="line">    Console.writeLine(hashtable[item]);<span class="comment">//值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历所有值</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">object</span> item <span class="keyword">in</span> hashtable.Values)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);<span class="comment">//值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//键值一起遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(DictionaryEntry <span class="built_in">object</span> item <span class="keyword">in</span> hashtable)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.key,item.Value);<span class="comment">//键，值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line">IDictionaryEnumerator myEnumerator= hashtable.GetEumerator();</span><br><span class="line"><span class="built_in">bool</span> flag=myEnumerator.MoveNext();</span><br><span class="line"><span class="keyword">while</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(myEnumerator.Key,myEnumerator,Value);<span class="comment">//键，值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//装箱拆箱</span></span><br><span class="line"><span class="comment">//不多说了</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>概念：实现了类型参数化，达到代码重用的目的，相当于类型占位符，定义类或者方法时使用替代符代表变量类型，当真正使用类或者方法时再具体指定类型。(c++中vector类)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类和泛型接口</span></span><br><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="keyword">class</span> 类名&lt;泛型占位字母&gt;</span><br><span class="line"><span class="title">interface</span> 接口名&lt;泛型占位字母&gt;</span><br><span class="line"><span class="comment">//泛型函数</span></span><br><span class="line"><span class="comment">//基本语法</span></span><br><span class="line">函数名&lt;泛型占位字母&gt;(参数列表) </span><br><span class="line"><span class="comment">//泛型占位字母可以有多个，用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类和接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestClass&lt;<span class="built_in">int</span>&gt; t=<span class="keyword">new</span> TestClass&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">t.<span class="keyword">value</span>=<span class="number">10</span>;</span><br><span class="line">Console.WriteLine(t.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">TestClass&lt;<span class="built_in">string</span>&gt;t2=<span class="keyword">new</span> TestClass&lt;<span class="built_in">string</span>&gt;();</span><br></pre></td></tr></table></figure>



<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>概念：让泛型有一定的限制，关键字：where</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型约束一共有6种</span></span><br><span class="line"><span class="comment">//值类型  where 泛型字母:struct</span></span><br><span class="line"><span class="comment">//引用类型 where 泛型字母:class</span></span><br><span class="line"><span class="comment">//存在无参公共构造函数 where 泛型字母:new()</span></span><br><span class="line"><span class="comment">//某个类本身 where 泛型字母:类名</span></span><br><span class="line"><span class="comment">//某个接口的派生类型 where 泛型字母:接口名</span></span><br><span class="line"><span class="comment">//另一个泛型类型本身或者派生类型 where 泛型字母:另一个泛型字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//where 泛型字母:(约束的类型)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值类型约束</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test1</span>&lt;<span class="title">T</span>&gt;<span class="keyword">where</span> <span class="title">T</span>:<span class="title">struct</span><span class="comment">//只能填值类型了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TextFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K,k</span>)<span class="keyword">where</span> K:<span class="keyword">struct</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt;<span class="keyword">where</span> <span class="title">T</span>:<span class="keyword">class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>&lt;<span class="title">K</span>&gt;(<span class="params">K,v</span>) <span class="keyword">where</span> K:<span class="keyword">class</span><span class="comment">//只能填引用类型</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="title">Test2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span>&gt;<span class="keyword">where</span> <span class="title">T</span>:<span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">K,k</span>)<span class="keyword">where</span> K:<span class="keyword">new</span>()<span class="comment">//只能填公共无参构造</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他类型不详细讲了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Test1&lt;<span class="built_in">object</span>&gt;t1=<span class="keyword">new</span> Test1&lt;<span class="built_in">object</span>&gt;();<span class="comment">//报错</span></span><br><span class="line">    Test1&lt;<span class="built_in">int</span>&gt;t2=<span class="keyword">new</span> Test2&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    Test3&lt;Test1&gt;t3=<span class="keyword">new</span> Test3&lt;Test1&gt;();</span><br><span class="line">    Test3&lt;Test2&gt;t4=<span class="keyword">new</span> Test3&lt;Test2&gt;();<span class="comment">//报错,Test2里面申明了有参构造函数将无参构造顶掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>是c#中封装好的一个类，是可变类型的泛型数组，List帮助我们实现了许多方法，类似于cpp中的vector</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt;list=<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">List&lt;<span class="built_in">string</span>&gt;list2=<span class="keyword">new</span> List&lt;<span class="built_in">bool</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">list.Add();</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">list.Remove();<span class="comment">//删除指定元素</span></span><br><span class="line">list.RemoveAt();<span class="comment">//删除指定下标元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">list[<span class="number">0</span>];<span class="comment">//和vector一样</span></span><br><span class="line">list.IndexOf();<span class="comment">//查找</span></span><br><span class="line">list.LastIndexOf();<span class="comment">//反向查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">list.Insert();<span class="comment">//插入指定位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">list.Count;</span><br><span class="line"><span class="comment">//容量</span></span><br><span class="line">list.Capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> temp <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>字典，有泛型的hashtable，就是hashtable,尽量用这个，别用非泛型类型，这个类型和hashtable的使用方法是一样的，这里笔者不多说了，和hashtable区别：找不到键的话直接报错，用TryGetValue方法不会报错</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>封装好的类，是一个泛型的双向链表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明</span></span><br><span class="line">LinkedList&lt;<span class="built_in">int</span>&gt;linkedlist=<span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾部添加元素</span></span><br><span class="line">linkedlist.AddLast();</span><br><span class="line"><span class="comment">//头部增加元素</span></span><br><span class="line">linkedlist.AddFirst();</span><br><span class="line"><span class="comment">//在某一个节点之后添加节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt;n=linkedlist.Find(<span class="number">20</span>);</span><br><span class="line">linkedlist.AddAfter(n,<span class="number">12</span>);<span class="comment">//在20元素的节点后插入加一个12的节点</span></span><br><span class="line"><span class="comment">//在某一个节点值之前</span></span><br><span class="line">AddBefore()<span class="comment">//用法和AddAfter()一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删</span></span><br><span class="line"><span class="comment">//移除头节点</span></span><br><span class="line">linkedlist.RemoveFirst();</span><br><span class="line"><span class="comment">//移除尾节点</span></span><br><span class="line">linkedlist.RemoveLast();</span><br><span class="line"><span class="comment">//移除指定节点</span></span><br><span class="line">linkedlist.Remove(具体元素);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">linkedlist.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查</span></span><br><span class="line"><span class="comment">//头节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt;first=linkedlist.First;</span><br><span class="line"><span class="comment">//尾节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt;last=linkedlist.Last;</span><br><span class="line"><span class="comment">//指定节点</span></span><br><span class="line">LinkedListNode&lt;<span class="built_in">int</span>&gt;node=linkedlist.Find(具体元素);<span class="comment">//没找到返回null</span></span><br><span class="line"><span class="comment">//是否存在</span></span><br><span class="line">linkedlist.Contains(元素);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line"><span class="comment">//先用查找得到节点</span></span><br><span class="line"><span class="comment">//再更改</span></span><br><span class="line">node.<span class="keyword">value</span>=新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> item <span class="keyword">in</span> linkedlist)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);<span class="comment">//直接得到里面的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p>和c++中的一样</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>概念：委托是函数的容器，可以理解为表示函数的变量类型，用来存储传递函数，委托的本质是一个类，用来定义函数的类型，不同的函数必须对应和各自“格式”一致的委托。（类似于函数指针）,可以作为某些触发机制，在前置条件完成后，将委托中的函数(行为)全部执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键字</span></span><br><span class="line"><span class="comment">//delegate</span></span><br><span class="line"><span class="comment">//语法：访问修饰符 delegate 返回值 委托名(参数列表);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写在哪里？</span></span><br><span class="line"><span class="comment">//可以申明在namespace和class语句块中</span></span><br><span class="line"><span class="comment">//更多的写在namespace中</span></span><br><span class="line"><span class="comment">//就是函数申明语法前加了一个delegate关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义自定义委托</span></span><br><span class="line"><span class="comment">//访问修饰符默认不写，为public，在别的命名空间也能用</span></span><br><span class="line"><span class="comment">//private 其他命名空间就不能用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//申明了一个可以用来存储无参无返回值函数的容器</span></span><br><span class="line"><span class="comment">//这里只是定义了规则 并没有使用</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>()</span>;</span><br><span class="line"><span class="comment">//同一语句块中，委托规则的申明是不能重名的</span></span><br><span class="line"><span class="comment">//用来装载或传递 返回值为int 有一个int参数的函数的 委托 容器规则</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;你好&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Fun2</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//专门用来装载函数的容器</span></span><br><span class="line">    MyFun f=<span class="keyword">new</span> MyFun(Fun);<span class="comment">//相当于将Fun()装载到了MyFun这个委托里面  </span></span><br><span class="line">    <span class="comment">//调用委托</span></span><br><span class="line">    f,Invoke();</span><br><span class="line">    <span class="comment">//作用：将函数存起来，之后调用</span></span><br><span class="line">    <span class="comment">//第二种方法</span></span><br><span class="line">    MyFun f2=Fun;</span><br><span class="line">    <span class="comment">//调用委托</span></span><br><span class="line">    f2();   </span><br><span class="line">    </span><br><span class="line">    Test t=<span class="keyword">new</span> Test();</span><br><span class="line">    </span><br><span class="line">    t.TestFun(Fun,Fun2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托常用在</span></span><br><span class="line"><span class="comment">//1.作为类的成员</span></span><br><span class="line"><span class="comment">//2.作为函数的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun fun;</span><br><span class="line">    <span class="keyword">public</span> MyFun2 fun2;<span class="comment">//两个委托类型的变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">MyFun fun,MyFun fun2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先处理一些别的逻辑，当这些逻辑处理完了，再执行传入的函数(延迟执行函数)</span></span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">        i+=<span class="number">2</span>;</span><br><span class="line">        i+=<span class="number">2</span>;</span><br><span class="line">        fun();</span><br><span class="line">        fun2(i);  </span><br><span class="line">        <span class="keyword">this</span>.fun=fun;</span><br><span class="line">        <span class="keyword">this</span>.fun2=fun2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="comment">//如果委托容器中没有对应函数，也不会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveFun</span>(<span class="params">MyFun fun,MyFun2 fun2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.fun-=fun;</span><br><span class="line">    <span class="keyword">this</span>.fun2-=fun2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托变量可以存储多个函数</span></span><br><span class="line"></span><br><span class="line">MyFun ff=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">ff+=Fun;<span class="comment">//委托增加函数</span></span><br><span class="line"></span><br><span class="line">ff+=Fun;</span><br><span class="line"></span><br><span class="line">ff();<span class="comment">//执行两次Fan()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空容器</span></span><br><span class="line">ff=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(ff!=<span class="literal">null</span>)<span class="comment">//如果ff不为空，执行</span></span><br><span class="line">&#123;</span><br><span class="line">    ff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统定义好的委托（使用系统自带的委托需要引用system）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>()</span>;<span class="comment">//无返回值无参函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span>  TResult <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;()</span>;<span class="comment">//泛型委托，可以自己填写任意类型返回值存储无参函数的委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;<span class="comment">//可以填最多16个参数的无返回值函数都可以放进去，系统里申明了16个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T</span>,<span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T arg</span>)</span>;<span class="comment">//有返回值的多参数委托，也是最多16个委托</span></span><br></pre></td></tr></table></figure>

<h2 id="回调机制（补充）"><a href="#回调机制（补充）" class="headerlink" title="回调机制（补充）"></a>回调机制（补充）</h2><p>回调是一种编程模式，其中一个函数作为参数传递给另一个函数，并在特定条件满足或者事件发生时调用。</p>
<p>一般可以使用委托实现。因为在回调中通常只存在一个订阅者，所以强调的是完成时调用我的单向通知，</p>
<p>调用者是知道被调用者的。</p>
<h2 id="观察者模式（补充）"><a href="#观察者模式（补充）" class="headerlink" title="观察者模式（补充）"></a>观察者模式（补充）</h2><p>观察者模式是一种行为设计模式，定义了对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象多会自动收到通知并更新。一般可以使用事件实现。因为观察者模式中通常有多个订阅者，强调“‘某事发生了”的广播通知，让多个订阅者知道事件的发生</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是基于委托的存在，事件是委托的安全包裹，让委托的使用更具有安全性，事件是一种特殊的变量类型，是特殊封装的委托。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="comment">//访问修饰符 event 委托类型 时间名;</span></span><br><span class="line"><span class="comment">//事件的使用:</span></span><br><span class="line"><span class="comment">//事件是作为成员变量存在于类中</span></span><br><span class="line"><span class="comment">//委托怎么用，事件就怎么用</span></span><br><span class="line"><span class="comment">//事件相对于委托的区别</span></span><br><span class="line"><span class="comment">//不能在类外部赋值</span></span><br><span class="line"><span class="comment">//不能再类外部调用</span></span><br><span class="line"><span class="comment">//只能作为成员存在于类和接口以及结构体中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//委托成员变量 用于存储函数的</span></span><br><span class="line"> <span class="keyword">public</span> Action myFun;</span><br><span class="line">    <span class="comment">//事件成员变量 用于存储函数的</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件和委托的使用一摸一样，只是有些细微的区别</span></span><br><span class="line">        myFun=TestFun;</span><br><span class="line">        myEvent=TestFun;</span><br><span class="line">        myEvent+=TestFun;<span class="comment">//也可以使用+-运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Test t = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">         t.myFun = <span class="literal">null</span>;<span class="comment">//可以</span></span><br><span class="line"></span><br><span class="line">         t.myEvent = <span class="literal">null</span>;<span class="comment">//报错，事件不能在类外部赋值</span></span><br><span class="line">         </span><br><span class="line">         t.myFun();<span class="comment">//可以</span></span><br><span class="line">         </span><br><span class="line">         t.myEvent();<span class="comment">//报错，事件不能再类外部调用</span></span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件有什么用</span></span><br><span class="line"><span class="comment">//防止外部随意清空委托</span></span><br><span class="line"><span class="comment">//防止外部随意调用委托</span></span><br><span class="line"><span class="comment">//事件相当于给委托进行了一次封装，使其更加安全</span></span><br></pre></td></tr></table></figure>

<h2 id="空条件运算符（补充）"><a href="#空条件运算符（补充）" class="headerlink" title="空条件运算符（补充）"></a>空条件运算符（补充）</h2><p>在调用委托和事件时通常要判断是否为空，具体可写一个条件语句判断，这里可以用更加简洁的空条件运算符(?.)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">event</span>!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">event</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和上面完全等价</span></span><br><span class="line"><span class="keyword">event</span>?.();</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>概念：没有名字的函数，主要是配合委托和事件进行使用，脱离委托和事件是不会使用匿名函数的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="comment">//delegate(参数列表)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//函数逻辑</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//何时使用</span></span><br><span class="line"><span class="comment">//函数中传递委托参数时</span></span><br><span class="line"><span class="comment">//委托或事件赋值时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">//无参数无返回</span></span><br><span class="line"><span class="comment">//这样申明匿名函数，只是声明函数而已，还没有调用</span></span><br><span class="line">Action a = <span class="built_in">delegate</span>()<span class="comment">//声明了一个没有名字的函数直接放进了委托中</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;匿名函数逻辑&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a();<span class="comment">//打印出上述函数内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; b = <span class="built_in">delegate</span>(<span class="built_in">int</span> a,<span class="built_in">string</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">b(<span class="number">100</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; c=  <span class="built_in">delegate</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;12345&quot;</span>;<span class="comment">//根据返回值自动判断返回类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(c());<span class="comment">//打印出&quot;12345&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般情况下会作为函数参数传递，或者作为函数返回值</span></span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line"><span class="comment">//参数传递</span></span><br><span class="line">t.Dosomething(<span class="number">100</span>,<span class="built_in">delegate</span>()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里可以写逻辑</span></span><br><span class="line">    <span class="comment">//可以直接现写一个函数放进委托里面</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line">t.GetFun()();<span class="comment">//t.GetFun返回的是委托，后面的括号相当于是调用委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action action;</span><br><span class="line">    <span class="comment">//作为参数传递时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomething</span>(<span class="params"><span class="built_in">int</span> a,Action fun</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作为返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span>()<span class="comment">//函数可以看作是特殊的委托，所以可以直接返回函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;函数内部返回的一个匿名函数逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数的缺点</span></span><br><span class="line"><span class="comment">//因为没有名字，单独添加到委托或者事件容器中后不记录 无法单独移除</span></span><br><span class="line"><span class="comment">//就算减等逻辑一样的匿名函数也没有作用</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>可以将lambda表达式理解为匿名函数的简写，他除了写法不同外，使用上和你匿名函数一样，都是和委托和事件配合使用的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line"><span class="comment">//(参数列表)=&gt;</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">//无参无返回值</span></span><br><span class="line">Action a = ()=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line"><span class="comment">//有参</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt; a =(<span class="built_in">int</span> b)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//有参数的lambda表达式</span></span><br><span class="line">&#125;;</span><br><span class="line">a2(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//参数类型都可以省略 参数类型和委托或者事件容器一致</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>&gt;a3= (<span class="keyword">value</span>)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//省略了参数类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有返回值</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt;a4=(<span class="keyword">value</span>)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包</span></span><br><span class="line"><span class="comment">//内层的函数可以引用包含在他外层的函数的变量（延长变量的生命周期）</span></span><br><span class="line"><span class="comment">//即使外层的函数已经终止</span></span><br><span class="line"><span class="comment">//该变量提供的值并非创建时的值，而是在父函数范围内的最终值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span>=<span class="number">30</span>;</span><br><span class="line">        </span><br><span class="line">        action=()=&gt;</span><br><span class="line">        &#123;</span><br><span class="line">         Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List排序"><a href="#List排序" class="headerlink" title="List排序"></a>List排序</h2><p>List自带的排序方法</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt;list=<span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list.Add(<span class="number">2</span>);</span><br><span class="line">list.Add(<span class="number">3</span>);</span><br><span class="line">list.Add(<span class="number">1</span>);</span><br><span class="line">list.Sort();<span class="comment">//排序方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类的排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Item</span>:<span class="title">IComparable</span>&lt;<span class="title">Item</span>&gt;<span class="comment">//继承排序接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">int</span> money</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.money=money;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Comparable</span>(<span class="params">Item other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回值的含义</span></span><br><span class="line">        <span class="comment">//小于0</span></span><br><span class="line">        <span class="comment">//放在传入对象的前面</span></span><br><span class="line">        <span class="comment">//等于0</span></span><br><span class="line">        <span class="comment">//保持当前对象的位置不变</span></span><br><span class="line">        <span class="comment">//大于0</span></span><br><span class="line">        <span class="comment">//放在传入对象的后面</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.money&gt;other.money)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写成return this.money&gt;other.money也可以</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Item&gt;itemList=<span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">itemList.Add(<span class="keyword">new</span> Item(<span class="number">34</span>));</span><br><span class="line">itemList.Add(<span class="keyword">new</span> Item(<span class="number">12</span>));</span><br><span class="line">itemList.Add(<span class="keyword">new</span> Item(<span class="number">23</span>));</span><br><span class="line">itemList.Add(<span class="keyword">new</span> Item(<span class="number">90</span>));</span><br><span class="line">itemList.Add(<span class="keyword">new</span> Item(<span class="number">89</span>));</span><br><span class="line"><span class="comment">//调用排序方法</span></span><br><span class="line">itemList.Sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过委托函数进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ShopItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShopItem</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;ShopItem&gt;shopItems=<span class="keyword">new</span> List&lt;ShopItem&gt;();</span><br><span class="line">shopItems.Add(<span class="keyword">new</span> ShopItem(<span class="number">3</span>));</span><br><span class="line">shopItems.Add(<span class="keyword">new</span> ShopItem(<span class="number">2</span>));</span><br><span class="line">shopItems.Add(<span class="keyword">new</span> ShopItem(<span class="number">1</span>));</span><br><span class="line">shopItems.Add(<span class="keyword">new</span> ShopItem(<span class="number">6</span>));</span><br><span class="line">shopItems.Add(<span class="keyword">new</span> ShopItem(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SortShopItem</span>(<span class="params">ShopItem a,ShopItem b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//传入的两个对象为列表的两个对象</span></span><br><span class="line">    <span class="comment">//进行两两比较，用左边的和右边的条件比较</span></span><br><span class="line">    <span class="comment">//返回值规则和之前的一样 0做标准 负数在左 正数在右</span></span><br><span class="line">    <span class="keyword">if</span>(a.id&gt;b.id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名函数写</span></span><br><span class="line">ShopItems.Sort((a,b)=&gt;&#123;<span class="keyword">return</span> a.id-b.id&#125;;);<span class="comment">//非常精简</span></span><br><span class="line"></span><br><span class="line">shopItems.Sort(SortShopItem);<span class="comment">//直接把函数传进去,使用排序函数</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h2><p>概念：协变：和谐的变化。因为里氏替换原则，父类可以装载子类，比如string变成object。</p>
<p>逆变：不正常的变化。比如object变成string。</p>
<p>协变和逆变是用来修饰泛型的</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协变：out</span></span><br><span class="line"><span class="comment">//逆变：in</span></span><br><span class="line"><span class="comment">//用于在泛型中修饰泛型字母的</span></span><br><span class="line"><span class="comment">//只有泛型接口和泛型委托能使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作用</span></span><br><span class="line"><span class="comment">//返回值和参数</span></span><br><span class="line"><span class="comment">//用out修饰的泛型，只能作为返回值</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"><span class="comment">//用in修饰的泛型，只能作为参数</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestOut</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span>:<span class="title">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//协变 父类总是可以被子类替换</span></span><br><span class="line">    <span class="comment">//看起来就是son --&gt;father</span></span><br><span class="line">    </span><br><span class="line">    TestOut&lt;Son&gt;os=()=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">reutrn <span class="keyword">new</span> <span class="title">Son</span>()</span>;  </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    TestOut&lt;Father&gt;of=os;<span class="comment">//放回的是Son类型</span></span><br><span class="line">    Father f=of();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆变</span></span><br><span class="line">   TestIn&lt;Father&gt;iF=(<span class="keyword">value</span>)=&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;;</span><br><span class="line">    </span><br><span class="line">    TestIn&lt;Son&gt;iS=iF;</span><br><span class="line">    iS(<span class="keyword">new</span> Son())<span class="comment">//实际上调用的是 iF的函数，但是传入的是Son类型变量</span></span><br><span class="line">        <span class="comment">//两个都符合里氏替换原则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>进程(process)是计算机的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。打开一次应用程序就是在操作系统中开启了一个进程，进程之间可以相互独立运行，互不干扰，也可以相互访问，操作。</p>
<p>线程，操作系统中能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位，一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程（简单理解：就是代码从上到下运行的一条管道）</p>
<p>多线程</p>
<p>我们可以通过代码开启新的线程。</p>
<p>同时运行代码的多条管道，就叫多线程。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类 Thread</span></span><br><span class="line"><span class="comment">//需要引用命名空间 using System.Threading;</span></span><br><span class="line"><span class="comment">//申明一个新的线程</span></span><br><span class="line"><span class="comment">//线程执行中的代码需要封装到一个函数中</span></span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(NewThreadLogic);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为后台线程</span></span><br><span class="line"><span class="comment">//当前台线程结束了的时候，整个程序就结束了，即使还有后台线程正在运行</span></span><br><span class="line"><span class="comment">//后台线程不会防止应用程序的进程被终止掉</span></span><br><span class="line"><span class="comment">//如果不设置为后台线程，可能导致进程无法正常关闭</span></span><br><span class="line">t.IsBackGround=<span class="literal">true</span>;<span class="comment">//设置为后台线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭释放一个线程</span></span><br><span class="line"><span class="comment">//如果开启的线程不是死循环，是能够结束的逻辑，那么不用特意的去关闭它</span></span><br><span class="line"><span class="comment">//如果是死循环，想要终止这个线程有两种方法</span></span><br><span class="line"><span class="comment">//死循环中bool标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过线程中提供的方法</span></span><br><span class="line"><span class="comment">//终止线程</span></span><br><span class="line">t.ABort();</span><br><span class="line">t=<span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新开线程 执行的代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程休眠</span></span><br><span class="line"><span class="comment">//让线程休眠多少毫秒</span></span><br><span class="line">Thread.Sleep();</span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程之间共享数据</span></span><br><span class="line"><span class="comment">//多个线程使用的内存是共享的，都属于该应用程序</span></span><br><span class="line"><span class="comment">//所以要注意 当多线程 同时操作同一片内存区域时可能会出问题</span></span><br><span class="line"><span class="comment">//可以通过加锁的形式避免问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//lock</span></span><br><span class="line"><span class="comment">//当我们想要在多个线程中访问同样的东西，进行逻辑处理时</span></span><br><span class="line"><span class="comment">//为了避免不必要的逻辑顺序执行的差错</span></span><br><span class="line"><span class="comment">//lock(引用类型对象)</span></span><br><span class="line"><span class="comment">//锁住同一个变量,当发现该变量没有被占用时再去执行代码块中的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程的意义</span></span><br><span class="line"><span class="comment">//寻路和网络通信等等</span></span><br></pre></td></tr></table></figure>



<h2 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h2><p>编译器：编译器是一种翻译程序，它用于将源语言程序翻译为目标语言程序</p>
<p>源语言程序：某种程序设计语言写成的，比如c#、c++等语言写成的程序</p>
<p>目标语言程序：二进制数表示的伪机器代码写的程序</p>
<p>预处理器指令：知道编译器在实际编译开始之前对信息进行预处理</p>
<p>预处理器都是以#开始</p>
<p>预处理器指令不是语句，所以他们不以分号结束，目前我们经常用到的折叠代码块就是预处理器指令</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define //定义一个符号</span></span><br><span class="line"><span class="comment">//写在脚本文件最前面的    </span></span><br><span class="line"><span class="comment">//#undef  //取消定义一个符号</span></span><br><span class="line"><span class="comment">//#if</span></span><br><span class="line"><span class="comment">//#elif</span></span><br><span class="line"><span class="comment">//#else</span></span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line"><span class="comment">//和if语句规则一样，一般配合#define定义的符号使用</span></span><br><span class="line"><span class="comment">//用于告诉编译器进行编译代码的流程控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#warning</span></span><br><span class="line"><span class="comment">//#error</span></span><br><span class="line"><span class="comment">//告诉编译器</span></span><br><span class="line"><span class="comment">//是报警告还是报错误</span></span><br><span class="line"><span class="comment">//一般还是配合if使用</span></span><br></pre></td></tr></table></figure>



<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>程序集：是经由编译器编译得到的，供进一步编译执行的那个中间产物，在windows系统中，他一般表现为后缀为：.dll(代码库文件)，或者是.exe(可执行文件)的格式。</p>
<p>程序集就是我们写的一个代码集合，我们现在的所有代码最终都会被编译器翻译为一个程序集供别人使用</p>
<p>元数据： 用来描述数据的数据。程序中的类、变量等等信息就是程序的元数据，保存在数据集中</p>
<p>反射：程序在运行时可以查看其它程序集或者自身的元数据。一个运行的程序查看本身或者其他程序的元数据的行为就叫做反射。就是在程序运行时，通过反射可以得到其他程序及或者他们自己程序集代码的各种信息。类、函数、变量、对象等等。实例化他们，执行他们。操作他们</p>
<p>反射可以在程序编译后获得信息，所以它提高了程序的拓展性和灵活性。</p>
<p>程序运行时得到所有元数据，包括元数据的特性。</p>
<p>程序运行时，实例化对象，操作对象</p>
<p>程序运行时创建新对象，用这些对象执行任务</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i,<span class="built_in">string</span> str</span>):<span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str=str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法相关</span></span><br><span class="line"><span class="comment">//Type</span></span><br><span class="line"><span class="comment">//它是反射功能的基础</span></span><br><span class="line"><span class="comment">//是访问元数据的主要方式</span></span><br><span class="line"><span class="comment">//使用Type的成员获取有关类型声明的信息</span></span><br><span class="line"><span class="comment">//有关类型的成员（如构造函数、方法、字段、属性和类的事件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Type</span></span><br><span class="line"><span class="comment">//万物之父object中的GetType()可以获取对象的Type</span></span><br><span class="line"><span class="built_in">int</span> a=<span class="number">32</span>;</span><br><span class="line">Type type=a.GetType();</span><br><span class="line">Console.Write(Type);</span><br><span class="line"><span class="comment">//打印出System Int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过typeof关键字 传入类名 也能得到对象的Type</span></span><br><span class="line">Type type2=<span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line">Console.Write(type2);</span><br><span class="line"><span class="comment">//同样可以得到类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类的名字也可以获得类型</span></span><br><span class="line"><span class="comment">//类名要包含命名空间</span></span><br><span class="line">Type type3=Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br><span class="line">Console.WriteLine(type3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面三个type指向的内存都是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到类的程序集信息</span></span><br><span class="line"><span class="comment">//可以通过Type得到类型所在的程序集信息</span></span><br><span class="line">Console.WriteLine(type1.Assembly);f</span><br><span class="line"><span class="comment">//打印出对应的程序集信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取类中的所有的公共成员</span></span><br><span class="line"><span class="comment">//首先得到对方的Type</span></span><br><span class="line">Type t=<span class="keyword">typeof</span>(Test);</span><br><span class="line"><span class="comment">//然后得到所有公共成员</span></span><br><span class="line"><span class="comment">//需要引用命名空间 using System.Reflection;</span></span><br><span class="line">MemberInfo[]infos=t.GetMembers();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;infos.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(infos[i]);</span><br><span class="line">&#125;<span class="comment">//得到所有公共成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取类的公共构造函数并调用</span></span><br><span class="line"><span class="comment">//获取所有构造函数</span></span><br><span class="line">ConstructorInfo[] ctors=t.GetConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;ctors.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(ctors[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取其中一个构造函数并执行</span></span><br><span class="line"><span class="comment">//得到构造函数传入 Type数组 数组中内容按顺序是参数类型</span></span><br><span class="line"><span class="comment">//执行构造函数传入 object数组 表示按顺序传入的参数</span></span><br><span class="line"><span class="comment">//得到无参构造</span></span><br><span class="line">ConstructInfo info=info=t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//执行无参构造 无参构造 没有参数 传null即可</span></span><br><span class="line">Test obj=info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;<span class="comment">//返回的是object变量，调用构造函数返回的Test类型，所以实际存放的又是Test类型，要用as转成Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到有参构造</span></span><br><span class="line">ConstructInfo info2=t.GetConstructor(<span class="keyword">new</span> Type[] &#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;);</span><br><span class="line">obj=info2.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[]&#123;<span class="number">2</span>&#125;)<span class="keyword">as</span> Test;</span><br><span class="line">Console.WriteLine(obj.str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有成员变量信息</span></span><br><span class="line">FieldInfo[] fieldInfos=t.GetFields();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;fieldinfos.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fieldinfos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到指定名称的公共成员变量信息</span></span><br><span class="line">FieldInfo infoJ=t.GetField(<span class="string">&quot;j&quot;</span>);<span class="comment">//传变量名</span></span><br><span class="line">Console.WriteLine(infoJ);</span><br><span class="line"><span class="comment">//通过反射获取和设置对象的值</span></span><br><span class="line">Test test=<span class="keyword">new</span> Test();</span><br><span class="line">test.j=<span class="number">99</span>;</span><br><span class="line">test.str=<span class="string">&quot;2222;</span></span><br><span class="line"><span class="string">//通过反射 获取对象的某个变量的值</span></span><br><span class="line"><span class="string">Console.WriteLine(infoJ.GetValue(test));</span></span><br><span class="line"><span class="string">//通过反射 设置指定对象的某个变量的值</span></span><br><span class="line"><span class="string">infoJ.SetValue(test,100);</span></span><br><span class="line"><span class="string">Console.WriteLine(infoJ.GetValue(Test));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//获取类的公共成员方法</span></span><br><span class="line"><span class="string">//通过Type类中的GetMethod方法，得到类中的方法</span></span><br><span class="line"><span class="string">//MethodInfo是方法的反射信息</span></span><br><span class="line"><span class="string">Type strType=typeof(string);</span></span><br><span class="line"><span class="string">//如果存在方法重载 用Type数组表示参数类型</span></span><br><span class="line"><span class="string">MethodInfo[] methods=strType.GetMethods();</span></span><br><span class="line"><span class="string">for(int i=0;i&lt;methods.Length;i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Console.WriteLine(methods[i]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//Activator</span></span><br><span class="line"><span class="string">//用于快速实例化对象的类</span></span><br><span class="line"><span class="string">//用于将Type对象快捷实例化为对象</span></span><br><span class="line"><span class="string">//先得到Type</span></span><br><span class="line"><span class="string">//然后 快速实例化一个对象</span></span><br><span class="line"><span class="string">Type testType =typeof(Test);</span></span><br><span class="line"><span class="string">//无参构造</span></span><br><span class="line"><span class="string">Test testObj=Activator.CreateInstace(testType) as Test;</span></span><br><span class="line"><span class="string">Console.WriteLine(testObj.str);</span></span><br><span class="line"><span class="string">//有参数构造</span></span><br><span class="line"><span class="string">testObj=Activator.CreateInstance(testType,99)as Test;//调用一个参数的构造函数</span></span><br><span class="line"><span class="string">Console.WriteLine(testObj.j);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testObj=Activator.CreateInstance(testType,88,&quot;</span><span class="number">14566</span><span class="string">&quot;)as Test;</span></span><br><span class="line"><span class="string">Console.WriteLine(testObj.j,testObj.str);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//Assembly</span></span><br><span class="line"><span class="string">//程序集类</span></span><br><span class="line"><span class="string">//主要用来加载其他程序集，加载后</span></span><br><span class="line"><span class="string">//才能用Type来使用其他程序集中的信息</span></span><br><span class="line"><span class="string">//比如想要使用不是自己程序集中的内容，首先要加载程序集</span></span><br><span class="line"><span class="string">//比如 dll文件（库文件）</span></span><br><span class="line"><span class="string">//简单地把库文件看成一种代码仓库，他提供给使用者一些可以直接拿来用的变量，函数或类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//三种加载程序集的函数</span></span><br><span class="line"><span class="string">//一般用来加载在同一文件下的其他程序集</span></span><br><span class="line"><span class="string">//Assembly assembly=Assembly.Load(&quot;</span>程序集名称<span class="string">&quot;);（同一工程）</span></span><br><span class="line"><span class="string">//Assembly assembly2=Assembly.LoadFrom(&quot;</span>包含程序集清单的文件的名称或路径<span class="string">&quot;);</span></span><br><span class="line"><span class="string">//Assembly assembly3=Assembly.LoadFile(&quot;</span>要加载文件的完全限定路径<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//先加载一个指定程序集</span></span><br><span class="line"><span class="string">Assembly assmbly=Assembly.LoadFrom(&quot;</span>略<span class="string">&quot;);</span></span><br><span class="line"><span class="string">Type[] types=assembly.GetTypes();</span></span><br><span class="line"><span class="string">for(int i=0;i&lt;types.Length;i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Console.WriteLine(types[i]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//之后再加载程序集中的一个类对象才能使用反射</span></span><br><span class="line"><span class="string">Type icon=assembly.GetType(&quot;</span>略<span class="string">&quot;);</span></span><br><span class="line"><span class="string">MemberInfo[] members=icon.GetMembers();</span></span><br><span class="line"><span class="string">for(int i=0;i&lt;members.Length;i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Console.WriteLine(Members[i]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//通过反射实例化icon对象</span></span><br><span class="line"><span class="string">//略</span></span><br></pre></td></tr></table></figure>

<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>特性是一种允许我们想程序的程序集添加元数据的语言结构，是用于保存程序结构信息的某种特殊类型的类。特性提供功能强大的方法以声明信息与c#代码相关联，特性与程序实体相关后即可在运行时使用反射查询特性信息。特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集中。可以放置在几乎所有的声明中。特性本质是一个类，可以利用特性类为元数据添加额外信息，之后可以用反射来获取这些额外信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义特性</span></span><br><span class="line"><span class="comment">//继承特性基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyCustomAttribute</span>:<span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特性中的成员 一般根据需求来写</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="built_in">string</span> info;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCustomAttribute</span>(<span class="params"><span class="built_in">string</span> info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;特性的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//特性的使用</span></span><br><span class="line"><span class="comment">//基本语法</span></span><br><span class="line"><span class="comment">//[特姓名(参数列表)]</span></span><br><span class="line"><span class="comment">//本质上 就是在调用特性类的构造函数</span></span><br><span class="line">[<span class="meta">MyCustom(<span class="string">&quot;田鼠浩二&quot;</span>)</span>]<span class="comment">//Attribute被系统默认省略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MyCustom(<span class="string">&quot;这是一个成员变量&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MuCustom(<span class="string">&quot;计算加法的函数&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun</span>(<span class="params">[MyCustom(<span class="string">&quot;函数参数&quot;</span></span>)]<span class="built_in">int</span> a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span> [] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;特性&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Myclass mc=<span class="keyword">new</span> MyClass();</span><br><span class="line">        Type t=mc.GetType();</span><br><span class="line">        t=<span class="keyword">typeof</span>(MyClass);</span><br><span class="line">        t=Type.GetType(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否使用了某个特性</span></span><br><span class="line">        <span class="comment">//参数一：特性的类型</span></span><br><span class="line">        <span class="comment">//参数二：是否搜索继承链(属性和时间忽略该参数)</span></span><br><span class="line">        <span class="comment">//只会判断类有没有应用，不判断成员</span></span><br><span class="line">        <span class="keyword">if</span>(t.IsDefind(<span class="keyword">typeof</span>(MyCustomAttribute),<span class="literal">false</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;该类型应用了MyCustom特性&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取Type元数据中的所有特性</span></span><br><span class="line">       <span class="built_in">object</span>[]array= t.getCustomAttributes(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;array.Length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] <span class="keyword">is</span> MyCustomAttribute)</span><br><span class="line">            &#123;</span><br><span class="line">              console.WriteLine((array[i] <span class="keyword">as</span> MyCustomAttribute).info);</span><br><span class="line">                (array[i] <span class="keyword">as</span> MyCustomAttribute).TestFun();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://takahasi193.github.io">takahasi193</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://takahasi193.github.io/2025/07/12/c-%E5%AD%A6%E4%B9%A0/">https://takahasi193.github.io/2025/07/12/c-%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://takahasi193.github.io" target="_blank">ようこそ、わが楽園へ!</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/simon1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/15/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" title="算法竞赛"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">算法竞赛</div></div><div class="info-2"><div class="info-item-1">复习用练习用多case解题这道题注意要开long long。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;typedef  long long ll;ll god(ll x,ll y)&#123; ll s=x*y;while(x%y)&#123; ll tmp=x%y;x=y;y=tmp;&#125;return s/y;&#125;int main()&#123; int n;cin&gt;&gt;n;while(n--)&#123;ll x,y;cin&gt;&gt;x&gt;&gt;y;cout&lt;&lt;god(x,y)&lt;&lt;endl;&#125;cout&lt;&lt;&quot;group 1...</div></div></div></a><a class="pagination-related" href="/2025/07/31/Unity/" title="Unity学习"><img class="cover" src="/kanon1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity学习</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/my894.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">takahasi193</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到鼠鼠的blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="toc-number">2.1.</span> <span class="toc-text">控制台方法相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3"><span class="toc-number">2.2.</span> <span class="toc-text">变量相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">2.4.</span> <span class="toc-text">异常捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.5.</span> <span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.6.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">随机数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">复杂数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.1.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">交错数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">值类型与引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">string类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref%E5%92%8Cout"><span class="toc-number">5.2.</span> <span class="toc-text">ref和out</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">变长参数和参数默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.4.</span> <span class="toc-text">结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">6.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.5.</span> <span class="toc-text">构造、析构、垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.6.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">6.7.</span> <span class="toc-text">成员属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">6.8.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">6.9.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89"><span class="toc-number">6.10.</span> <span class="toc-text">静态类和静态构造函数（工具类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">6.11.</span> <span class="toc-text">拓展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">6.12.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%88%86%E5%B8%83%E7%B1%BB"><span class="toc-number">6.13.</span> <span class="toc-text">内部类和分布类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">继承的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88LSP%EF%BC%89%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E4%B8%80%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">里氏替换原则（LSP）（面向对象七大原则之一）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">继承中的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E5%92%8C%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1"><span class="toc-number">7.4.</span> <span class="toc-text">万物之父和装箱拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">密封类（不是很重要）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81vob"><span class="toc-number">8.1.</span> <span class="toc-text">多态vob</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">抽象类和抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.3.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">密封函数（不是很重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">8.6.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.7.</span> <span class="toc-text">万物之父中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">8.8.</span> <span class="toc-text">string类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder"><span class="toc-number">8.9.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.10.</span> <span class="toc-text">类和结构体的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">8.11.</span> <span class="toc-text">多脚本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">8.12.</span> <span class="toc-text">UML类图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">面向对象七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-SRP"><span class="toc-number">9.1.</span> <span class="toc-text">单一职责原则(SRP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-OCP"><span class="toc-number">9.2.</span> <span class="toc-text">开闭原则(OCP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-LSP"><span class="toc-number">9.3.</span> <span class="toc-text">里氏替换原则(LSP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99-DIP"><span class="toc-number">9.4.</span> <span class="toc-text">依赖倒转原则(DIP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99-LoP"><span class="toc-number">9.5.</span> <span class="toc-text">迪米特原则(LoP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99-ISP"><span class="toc-number">9.6.</span> <span class="toc-text">接口分离原则(ISP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99-CRP"><span class="toc-number">9.7.</span> <span class="toc-text">合成复用原则(CRP)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-number">10.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">10.2.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">10.3.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable"><span class="toc-number">10.4.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.5.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">10.6.</span> <span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">泛型数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">11.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dictionary"><span class="toc-number">11.2.</span> <span class="toc-text">Dictionary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-number">11.3.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">11.4.</span> <span class="toc-text">泛型栈和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">11.5.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">11.6.</span> <span class="toc-text">回调机制（补充）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">观察者模式（补充）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.8.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">11.9.</span> <span class="toc-text">空条件运算符（补充）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">11.10.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.11.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E6%8E%92%E5%BA%8F"><span class="toc-number">11.12.</span> <span class="toc-text">List排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98"><span class="toc-number">11.13.</span> <span class="toc-text">协变逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.14.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">11.15.</span> <span class="toc-text">预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">11.16.</span> <span class="toc-text">反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">12.</span> <span class="toc-text">特性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/07/%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8B%89%E5%BC%B7/" title="日本語勉強"><img src="/scarlet1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="日本語勉強"/></a><div class="content"><a class="title" href="/2025/09/07/%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8B%89%E5%BC%B7/" title="日本語勉強">日本語勉強</a><time datetime="2025-09-07T08:48:14.000Z" title="发表于 2025-09-07 16:48:14">2025-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/07/Unity-UI%E7%9B%B8%E5%85%B3/" title="Unity-UI相关"><img src="/fuyuka1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-UI相关"/></a><div class="content"><a class="title" href="/2025/09/07/Unity-UI%E7%9B%B8%E5%85%B3/" title="Unity-UI相关">Unity-UI相关</a><time datetime="2025-09-07T03:33:50.000Z" title="发表于 2025-09-07 11:33:50">2025-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/15/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="数据持久化"><img src="/sayumi1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据持久化"/></a><div class="content"><a class="title" href="/2025/08/15/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="数据持久化">数据持久化</a><time datetime="2025-08-15T09:57:29.000Z" title="发表于 2025-08-15 17:57:29">2025-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/31/Unity/" title="Unity学习"><img src="/kanon1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity学习"/></a><div class="content"><a class="title" href="/2025/07/31/Unity/" title="Unity学习">Unity学习</a><time datetime="2025-07-31T15:01:45.000Z" title="发表于 2025-07-31 23:01:45">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/12/c-%E5%AD%A6%E4%B9%A0/" title="c#学习"><img src="/simon1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c#学习"/></a><div class="content"><a class="title" href="/2025/07/12/c-%E5%AD%A6%E4%B9%A0/" title="c#学习">c#学习</a><time datetime="2025-07-12T15:00:15.000Z" title="发表于 2025-07-12 23:00:15">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By takahasi193</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script> - <script async src="/js/title.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="失礼,嚙みました,かみまみた！" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>